{"state":{"content":"<h1>Defining a Perseus App</h1>\n<p>Once you've got all your dependencies installed, it's time to create the entrypoint to your Perseus app. In most Rust programs. you'll have a <code>main.rs</code> file that contains some <code>fn main() { .. }</code> that executes yuor code, and Perseus is no exception. However, remember that Perseus has two parts: the engine-side and the client-side, so you actually need <em>two</em> <code>main()</code> functions, one for each. Now, don't put anything in <code>src/main.rs</code> just yet, because, as we'll see later, there's actually a much more convenient way of handling all this.</p>\n<p>Remember, you can tell Rust to only compile some code on the engine-side by putting <code>#[cfg(engine)]</code> over it, and you can use <code>#[cfg(client)]</code> to do the same for the browser. So, our code in <code>main.rs</code> should logically look something like this:</p>\n<pre><code class=\"language-rust\">#[cfg(engine)]\nfn main() {\n    // Engine code here\n}\n\n#[cfg(client)]\nfn main() {\n    // Browser code here\n}\n</code></pre>\n<p>Now, this actually isn't too far off, except that running WebAssembly is a little different than you might think. Currently, there isn't really a good concept of a 'binary' Wasm program, you'll always be coding a library that some JavaScript imports and runs. In the case of Perseus apps, we use a <code>main.rs</code> file because it makes more logical sense, since Perseus handles all that nasty JS stuff behind the scenes. From your point of view, you're just writing a normal binary. However, there is something special that the client-side function has to do: it has to return a <code>Result&lt;(), JsValue&gt;</code>, where <code>JsValue</code> is a special type that represents <em>stuff</em> in JS-land. You can use Perseus' <a href=\"https://docs.rs/perseus/0.4.0-beta/perseus/type.ClientReturn.html\"><code>ClientReturn</code></a> type alias for this, but note that Perseus actually <em>can't</em> return an error from its invocation: all errors are gracefully handled, even panics (although they will eventually propagate up as an unhandled exception in the calling JS, which is why any panics in Perseus will appear as two messages in your browser console rather than one).</p>\n<p>Further, Perseus makes the engine and client code pretty convenient with two features (which are enabled by default): <code>dflt-engine</code>, and <code>client-helpers</code>. The first of these gives us the <a href=\"https://docs.rs/perseus/0.4.0-beta/perseus/engine/fn.run_dflt_engine.html\"><code>run_dftl_engine()</code></a> fucntion, which takes an <a href=\"https://docs.rs/perseus/0.4.0-beta/perseus/engine/enum.EngineOperation.html\"><code>EngineOperation</code></a> derived from the <a href=\"https://docs.rs/perseus/0.4.0-beta/perseus/engine/fn.get_op.html\"><code>get_op()</code></a> function (which just parses environment variables passed through by the CLI), a function that returns a <a href=\"=prelude/struct.PerseusAppBase\"><code>PerseusApp</code></a> (whcih we'll get to), and some function to run your server.</p>\n<p>As for the client-side, Perseus provides <code>run_client()</code>, which just takes a function that returns a <code>PerseusApp</code>.</p>\n<p>So what is this <code>PerseusApp</code>, you might ask? This <code>struct</code> forms the bridge between Perseus' internals, and your own code, because it's how you tell Perseus what your app looks like. In fact, because the vast majority of engine and client <code>main()</code> functions are so formulaic, Perseus provides a convenient macro, <a href=\"https://docs.rs/perseus/0.4.0-beta/perseus/attr.main.html\"><code>#[perseus::main(..)]</code></a>, which you can use to annotate a <em>single</em> <code>main()</code> function that returns a <code>PerseusApp</code>, and that macro will then do the rest automatically. Most of time, this is what you want, but you can always take a look at <a href=\"\">the source code</a> of that macro if you want to drill deeper into customizing your app (again, you will probably <em>never</em> need to do this, even if you're creating an insanely advanced app).</p>\n<p>So, our actual <code>src/main.rs</code> file would look something like this (theory over, <em>now</em> we start coding):</p>\n<pre><code class=\"language-rust\">mod error_views;\nmod templates;\n\nuse perseus::prelude::*;\n\n#[perseus::main(perseus_warp::dflt_server)]\npub fn main&lt;G: Html&gt;() -&gt; PerseusApp&lt;G&gt; {\n    PerseusApp::new()\n        .template(crate::templates::index::get_template())\n        .template(crate::templates::about::get_template())\n        .error_views(crate::error_views::get_error_views())\n}\n\n</code></pre>\n<p>First off, we declare a module called <code>templates</code>, which will correspond to the <code>src/templates/</code> folder, which we'll use to store the code for all our templates. Go ahead and create that folder now, with an empty <code>mod.rs</code> file inside. The next thing is to import the Perseus <code>prelude</code> module, which just collates everything you'll need to run a Perseus app, which helps to avoid having to manually import a million different things. Most of your Perseus files will begin with <code>use perseus::prelude::*;</code>, and then <code>use sycamore::prelude::*;</code></p>\n<p>Then we get to that special <code>main()</code> function. As you can see, it returns a <code>PerseusApp</code>, which takes a generic <code>G</code>: this is a special part of Sycamore that lets is say &quot;let this function work with any rendering backend that implements <code>Html</code>&quot;, because Sycamore can actually go way beyond the web! This generic restricts us to using <code>SsrNode</code> (for prerendering), <code>DomNode</code> (for rendering to the Document Object Model in the browser), or <code>HydrateNode</code> (the same as <code>DomNode</code>, but for when we're [hydrating]).</p>\n<p>You'll also notice that we've provided an argument to the <code>#[perseus::main(..)]</code> attribute macro: that's the function that will start up our server! If you want to add things like custom API routes, etc., then you can set this function manually, and then use one of the Perseus server integrations to work with the code you've written (see [this example] for more), but here we're just using the default server from the <code>perseus-warp</code> package. If you fancy [Axum], you can use <code>perseus-axum</code>, and [Actix Web] fans can use the <code>perseus-actix-web</code> package!</p>\n<h2>Your <code>PerseusApp</code></h2>\n<p>Now we get to the fun stuff: actually defining your app! The first step is to invoke <code>PerseusApp::new()</code>, which is what you'll nearly always want, unless you're in an environment with very special characteristics (e.g. a serverless function with a read-only filesystem), or if you want to manage your translations in a non-standard way for internationalization. Again, 99% of the time, <code>PerseusApp::new()</code> is fine.</p>\n<p>The next thing we do is declare our templates, which we'll create in a moment. Generally, in Perseus, you'll have an <code>src/templates/</code> folder that contains all your templates, and each template will export a <code>get_template()</code> function that you call from here. However, if you're from JS-land, where you might be used to something called <em>filesystem routing</em> (in which the nesting of a file implies the route it will be hosted at), Perseus has no such thing. If you want to store the about page at <code>index.rs</code> and the index page at <code>about.rs</code>, have fun!</p>\n<p>The next thing we do is specify some <a href=\"https://docs.rs/perseus/0.4.0-beta/perseus/error_views/struct.ErrorViews.html\"><code>ErrorViews</code></a>, which are responsible for doing all the error handling in our app. We'll cover this in more detail in <a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/error-handling\">the error handling section</a>, but just know for now that Perseus has a very strict error handling system, and, unlike a lot of other frameworks, there is no such thing as an unhandled error in Perseus: <em>everything</em> is handled (even panics, though they're a bit special).</p>\n<p>Of course, you usually just want to dive straight into your app, so you can leave the <code>.error_views()</code> bit out if you like, and Perseus will provide some sensible defaults while you're still in development. However, if you try to deploy your app with those defaults, you'll get errors. </p>\n<p>(Note that you might see <code>ErrorViews::unlocalized_development_defaults()</code> hanging around a lot in the examples, which basically tells Perseus to force-use those 'sensible defaults' in production as well. This is very convenient for examples about how to use Perseus, but it's almost certainly a bad idea in your own code, especially if you want your app available in multiple languages!)</p>\n<p>With all that explained, it's time to create some pages!</p>\n","current_version":"next","manifest":{"0.1.x":{"docs_rs":"0.1","git":"v0.1.4","state":"outdated"},"0.2.x":{"docs_rs":"0.2","git":"v0.2.3","state":"outdated"},"0.3.0-0.3.3":{"docs_rs":"0.3.3","git":"v0.3.3","state":"outdated"},"0.3.4":{"docs_rs":"0.3","git":"v0.3.6","state":"stable"},"0.4.x":{"docs_rs":"0.4.0-beta","git":"HEAD","state":"beta"}},"sidebar_content":"<h1>Introduction</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/intro\">Introduction</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/quickstart\">Quickstart</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/what-is-perseus\">What is Perseus?</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/core-principles\">Core Principles</a></li>\n</ul>\n<h1>Your First App</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/installation\">Installing Perseus</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/defining\">Defining your app</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/generating-pages\">Generating pages</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/dev-cycle\">Development cycle</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/error-handling\">Error handling</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/deploying\">Deploying your app</a></li>\n</ul>\n<h1>Fundamentals</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/perseus-app\"><code>PerseusApp</code></a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/reactor\">The reactor</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/routing\">Routing and navigation</a>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/preloading\">Preloading</a></li>\n</ul>\n</li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/i18n\">Internationalization</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/error-views\">Error views</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/hydration\">Hydration</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/static-content\">Static content</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/styling\">Styling</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/js-interop\">Working with JS</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/serving-exporting\">Servers and exporting</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/debugging\">Debugging</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/testing\">Writing tests</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/plugins\">Plugins</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/compilation-times\">Improving Compilation Times</a></li>\n</ul>\n<h1>The State Platform</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/intro\">Understanding state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/build\">Build-time state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/request\">Request-time state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/revalidation\">Revalidation</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/incremental\">Incremental generation</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/browser\">Using state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/global\">Global state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/helper\">Helper state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/suspense\">Suspended state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/freezing-thawing\">Freezing and thawing</a></li>\n</ul>\n<h1>Capsules</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/capsules/intro\">Introduction</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/capsules/capsules-vs-templates\">Capsules vs. templates</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/capsules/delayed\">Delayed widgets</a></li>\n</ul>\n<h1>Miscellaneous</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/migrating\">Migrating from v0.3.x</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/faq\">Common pitfalls and FAQs</a></li>\n</ul>\n","status":"Next","title":"Defining a Perseus App"},"head":"<title>Defining a Perseus App | Perseus Docs</title><link rel=\"stylesheet\" href=\".perseus/static/styles/markdown.css\"/><link rel=\"stylesheet\" href=\".perseus/static/styles/docs_links_markdown.css\"/><link rel=\"stylesheet\" href=\".perseus/static/prism.css\"/>"}