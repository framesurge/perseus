{"state":{"content":"<h1>Build-time state</h1>\n<p>The most commonly used part of the Perseus state platform is the <em>build-time state</em> system, which generates state when you run <code>perseus build</code> (or one of the other commands that invokes it, like <code>serve</code>, <code>export</code>, etc.). There are two main parts to the build state system: <em>build paths</em>, and <em>build state</em> itself.</p>\n<h2>Build state</h2>\n<p>The fundamental idea of build state is very simple: you define an asynchronous function that does whatever it wants, and eventually comes back with some state, and then Perseus runs that function during the build process, and saves that state to an internal file (in the magical depths of <code>dist/</code>) for later use. This also allows Perseus to prerender any pages using build state to HTML as soon as their state is ready, meaning they can be served almost instantly when they're requested.</p>\n<p>Using build state is very simple, here's an example.</p>\n<pre><code class=\"language-rust\">use perseus::prelude::*;\nuse serde::{Deserialize, Serialize};\nuse sycamore::prelude::*;\n\n#[derive(Serialize, Deserialize, Clone, ReactiveState)]\n#[rx(alias = &quot;PageStateRx&quot;)]\nstruct PageState {\n    greeting: String,\n}\n\nfn build_state_page&lt;'a, G: Html&gt;(cx: BoundedScope&lt;'_, 'a&gt;, state: &amp;'a PageStateRx) -&gt; View&lt;G&gt; {\n    view! { cx,\n        p { (state.greeting.get()) }\n    }\n}\n\npub fn get_template&lt;G: Html&gt;() -&gt; Template&lt;G&gt; {\n    Template::build(&quot;build_state&quot;)\n        .build_state_fn(get_build_state)\n        .view_with_state(build_state_page)\n        .build()\n}\n\n// We're told the path we're generating for (useless unless we're using build\n// paths as well) and the locale (which will be `xx-XX` if we're not using i18n)\n// Note that this function is asynchronous, so we can do work like fetching from\n// a server or the like here (see the `demo/fetching` example), along with any\n// helper state we generated with build paths (which we aren't using, hence the\n// `()`)\n//\n// This returns a `Result` with a `BlamedError`, because, if we were using\n// *incremental generation*, then build state might be executed again in future\n// (see `incremental_generation.rs` for an example of that).\n#[engine_only_fn]\nasync fn get_build_state(\n    _info: StateGeneratorInfo&lt;()&gt;,\n) -&gt; Result&lt;PageState, BlamedError&lt;std::io::Error&gt;&gt; {\n    Ok(PageState {\n        greeting: &quot;Hello World!&quot;.to_string(),\n    })\n}\n\n</code></pre>\n<p>The main features of this file are the definition of a state type (see <a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/generating-pages\">here</a> for a refresher on this) <code>PageState</code> that's reactive, and the use of <code>.build_state_fn()</code> on the <code>Template</code> definition. A function is then provided to this that meets a certain set of criteria: it has to be <code>async</code>, it can return an error or be infallible, and it has to return something that makes sense as a state type (i.e. something that you've derived either <code>ReactiveState</code> or <code>UnreactiveState</code> on).</p>\n<p>Now let's drill into what's happening in that <code>get_build_state</code> function. Obviously the logic is very simple, it's just returning a static string, but this could be entirely arbtirary. You could fetch from a database here, you could perform complex calculations, heck, you could deploy an army of carrier pigeons and wait for sensor events that tell you when a certain portion have returned if you really want!</p>\n<p>The important thing to understand about build state more generally is the signature of this function. It's <code>async</code>, as explained earlier, and has access to a <a href=\"https://tokio.rs\">Tokio</a> 1.x runtime. It takes a single argument (unused here) of the type <a href=\"https://docs.rs/perseus/0.4.0-beta/perseus/prelude/struct.StateGeneratorInfo.html\"><code>StateGeneratorInfo</code></a>, which is actually extremely simple, it's just an organizational type. All it stores is the path to the page being built (e.g. if you're building state for <code>/post/foo</code> in the <code>post</code> template, this would be <code>foo</code>), the locale being built for, and any <a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/helper\">helper state</a> you might have defined (which is what the generic is for). Here, we haven't defined any helper state, so the generic is set to the unit type <code>()</code>.</p>\n<h3>Error handling</h3>\n<p>As mentioned, functions that generate build state can either be <em>infallible</em> (meaning they can't return errors, and they just return the state type), or <em>fallible</em> (meaning they return a <code>Result</code>). As much as possible, you should avoid <code>panic!</code>ing in any state generation functions, especially in apps using features like revalidation or incremental generation, since, if any of those panics occur on the client-side, the server will have to manage panicking threads. This is fine, and your app will be unaffected for other users, but it's terrible practice and will lead to the user whose query caused the panic waiting forever for a page to load that never will. Not ideal! Instead, try to gracefully return errors wherever you can, so that Perseus can convert those into nice <a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/error-views\">error views</a>.</p>\n<p>But, you might be thinking, doesn't this function only run at build-time? Well, that's the reason for that <a href=\"https://docs.rs/perseus/0.4.0-beta/perseus/prelude/struct.BlamedError.html\"><code>BlamedError</code></a> type wrapping our error type here. Now, you can return any error from any Perseus state generation function, as long as it implements <code>std::error::Error</code>, but some of them will require you to wrap it in this <code>BlamedError&lt;E&gt;</code> type, where <code>E</code> is your error. This is a special type that annotates your error with an <a href=\"https://docs.rs/perseus/0.4.0-beta/perseus/prelude/enum.ErrorBlame.html\"><code>ErrorBlame</code></a>, which says who was responsible for the error: either the client, or the server.</p>\n<p>But, again, doesn't this function only run at build-time? How can the client possibly be responsible for any failure there? They can't be, of course, but, if you're using a feature like <a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/revalidation\">revalidation</a>, where build-time state is updated at request-time, it is entirely possible that this function will be executed at request-time, and a user could be responsible for any errors then. In this example, that can't happen, but Perseus doesn't know that.</p>\n<p>Conveniently, <code>BlamedError</code> has a number of helpful conversions available to it that allow you to automatically convert from your error type into it. For instance, if you were to return some error <code>err</code>, you could do so with <code>return Err(err.into())</code>, or <code>result?</code> (since the <code>?</code> operator automatically attempts a conversion). Such automatic conversions will implicitly blame the server for the error (which is usually what you want). The one time this can become annoying is when you have a complex error type with multiple subtypes (e.g. <code>MyError</code> has variants for <code>MyFooError</code> and <code>MyBarError</code>). Even if you've implemented <code>From&lt;MyFooError&gt; for MyError</code>, you still can't use <code>?</code> as usual, because there are <em>two</em> conversions that need to take place: the one into <code>MyError</code>, and then another into <code>BlamedError&lt;MyError&gt;</code>. Until Rust supports custom implementations of <code>?</code> (which will alleviate this problem entirely), the best you can do is <code>my_foo_result.map_err(MyError::from)?</code>, which will handle both conversions relatively briefly.</p>\n<p>This same error handling behavior applies for the vast majority of Perseus state generation functions.</p>\n<h2>Build paths</h2>\n<p>Build paths are a very simple strategy that allows you to return a list of pages that should be rendered within your template. For example, if you return a list containing <code>foo</code>, <code>bar</code>, and <code>baz</code> for the <code>test</code> template, you'll get pages <code>/test/foo</code>, <code>/test/bar</code>, and <code>/test/baz</code>. If you also returned <code>foo/bar/baz</code>, you'd get another page <code>/test/foo/bar/baz</code>, which is perfectly acceptable.</p>\n<details>\n<summary>Can two templates have conflicting paths?</summary>\n<p>No, because templates can only render paths within their own path. However, it's possible to have a situation where you have, say, one template called <code>foo</code> that renders a page <code>bar</code>, leading to <code>/foo/bar</code>, and another template actually named <code>foo/bar</code> (since templates can be at lower paths). This would be a problem, and only one page would be resolved (depending on the order of the build process, which is parallelized, this could be either). If the <code>foo</code> template is using incremental generation though, don't worry, since exact paths are always given priority over incremental ones. 99.9% of the time, you will not have to worry about routing conflicts like this.</p>\n</details>\n<p>Here's an example of using build paths:</p>\n<pre><code class=\"language-rust\">use perseus::prelude::*;\nuse serde::{Deserialize, Serialize};\nuse sycamore::prelude::*;\n\n#[derive(Serialize, Deserialize, Clone, ReactiveState)]\n#[rx(alias = &quot;PageStateRx&quot;)]\nstruct PageState {\n    title: String,\n    content: String,\n}\n\nfn build_paths_page&lt;'a, G: Html&gt;(cx: BoundedScope&lt;'_, 'a&gt;, state: &amp;'a PageStateRx) -&gt; View&lt;G&gt; {\n    view! { cx,\n        h1 {\n            (format!(&quot;build_paths/{}&quot;, state.title.get()))\n        }\n        p {\n            (state.content.get())\n        }\n    }\n}\n\npub fn get_template&lt;G: Html&gt;() -&gt; Template&lt;G&gt; {\n    Template::build(&quot;build_paths&quot;)\n        .build_paths_fn(get_build_paths)\n        .build_state_fn(get_build_state)\n        .view_with_state(build_paths_page)\n        .build()\n}\n\n// We take in `StateGeneratorInfo`, which has the path we're generating for\n// (*not* including the template name), along with the locale, and some\n// arbitrary helper state (which we're not using, hence the `()`)\n//\n// This could be fallible with a `BlamedError`\n#[engine_only_fn]\nasync fn get_build_state(info: StateGeneratorInfo&lt;()&gt;) -&gt; PageState {\n    let title = info.path.clone();\n    let content = format!(\n        &quot;This is a post entitled 'build_paths/{}'. Its original slug was 'build_paths/{}'.&quot;,\n        &amp;title, &amp;info.path\n    );\n\n    PageState { title, content }\n}\n\n// This just returns a special `struct` containing all the paths we want to\n// generate underneath `build_paths` (the template's name and root path). Like\n// for build state, this function is asynchronous, so you could fetch these\n// paths from a database or the like Note that everything you export from here\n// will be prefixed with `&lt;template-name&gt;/` when it becomes a URL in your app\n//\n// Note also that there's almost no point in using build paths without build\n// state, as every page would come out exactly the same (unless you\n// differentiated them on the client...)\n//\n// This could return `BuildPaths` directly; this example just shows that it\n// could also return an error (which is *not* blamed, since this function, which\n// generates paths at build-time, is only going to be run at...well, build-time,\n// so the client can't be responsible for any errors we might encounter)\n#[engine_only_fn]\nasync fn get_build_paths() -&gt; Result&lt;BuildPaths, std::convert::Infallible&gt; {\n    Ok(BuildPaths {\n        // These are the paths we want to generate for, with an empty string being at the root of\n        // the template name (here, `/build_paths`)\n        paths: vec![\n            &quot;&quot;.to_string(),\n            &quot;test&quot;.to_string(),\n            &quot;blah/test/blah&quot;.to_string(),\n            &quot;a test&quot;.to_string(), // Perseus can even handle paths with special characters!\n        ],\n        // Sometimes, you want to do something once to generate some helper state for building each\n        // page, and you can put literally anything in here (but we're not using it).\n        // The `.into()` makes sure Perseus can understand whatever we put in here.\n        extra: ().into(),\n    })\n}\n\n</code></pre>\n<p>This may look slightly more intimidating than the previous example, but all that's been added is a new <code>get_build_paths</code> function, which is basically identical in terms of error handling, etc. to <code>get_build_state</code>, except it will <em>never</em> be run at request-time, so it can return a normal error, which will be blamed on the server. It also returns an organizational type <a href=\"https://docs.rs/perseus/0.4.0-beta/perseus/prelude/struct.BuildPaths.html\"><code>BuildPaths</code></a>, which has two parameters: the first is a list of paths, and the second is an <code>extra</code> property, which relates to <a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/helper\">helper build state</a>. Since we're not using it here, we just use <code>()</code>, converted into what Perseus expects with <code>.into()</code> (you can read more about this <a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/helper\">here</a>).</p>\n<p>The main thing about build paths is that list, which contains an empty string (which will, since the name of this template has been set to <code>build_paths</code>, for demonstration purposes, render at <code>/build_paths</code>, since the empty string indicates the page at the root of the template), and several other paths. One of these is nested, showing that that's possible, and another contains a space, which Perseus will automatically handle URL encoding/decoding of (since browsers don't like special characters like those, and use a thing called <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding\">percent encoding</a> to work around them).</p>\n<p><em>Note: support for other special characters, especially non-ASCII characters, is currently untested in Perseus. If you have problems with this, please report them, or let us know if things work as expected for you!</em></p>\n<p>Note that here we've used <code>std::convert::Infallible</code> as the error type to show that you can return errors, but, since this function really is infallible, we could have just returned <code>BuildPaths</code> directly. As with other state generation functions, the build paths function is asynchronous, meaning you can do more complex work without disrupting the rest of the build process.</p>\n<p>Remember that any paths you don't generate under the template will resolve to <em>404 Not Found</em> errors (e.g. <code>/build_paths/tests</code>, here, because it's not in that list). Also, if you don't explicitly specify the empty string here, the template will have no root page.</p>\n<p>Finally, notice how <code>get_build_paths</code> works here: we're using the <code>path</code> property of <a href=\"https://docs.rs/perseus/0.4.0-beta/perseus/prelude/struct.StateGeneratorInfo.html\"><code>StateGeneratorInfo</code></a> to produce a <code>PageState</code> that is path-dependent. </p>\n","current_version":"next","manifest":{"0.1.x":{"docs_rs":"0.1","git":"v0.1.4","state":"outdated"},"0.2.x":{"docs_rs":"0.2","git":"v0.2.3","state":"outdated"},"0.3.0-0.3.3":{"docs_rs":"0.3.3","git":"v0.3.3","state":"outdated"},"0.3.4":{"docs_rs":"0.3","git":"v0.3.6","state":"stable"},"0.4.x":{"docs_rs":"0.4.0-beta","git":"HEAD","state":"beta"}},"sidebar_content":"<h1>Introduction</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/intro\">Introduction</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/quickstart\">Quickstart</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/what-is-perseus\">What is Perseus?</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/core-principles\">Core Principles</a></li>\n</ul>\n<h1>Your First App</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/installation\">Installing Perseus</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/defining\">Defining your app</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/generating-pages\">Generating pages</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/dev-cycle\">Development cycle</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/error-handling\">Error handling</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/deploying\">Deploying your app</a></li>\n</ul>\n<h1>Fundamentals</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/perseus-app\"><code>PerseusApp</code></a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/reactor\">The reactor</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/routing\">Routing and navigation</a>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/preloading\">Preloading</a></li>\n</ul>\n</li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/i18n\">Internationalization</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/error-views\">Error views</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/hydration\">Hydration</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/static-content\">Static content</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/head-headers\">Heads and headers</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/styling\">Styling</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/js-interop\">Working with JS</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/serving-exporting\">Servers and exporting</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/debugging\">Debugging</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/testing\">Writing tests</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/plugins\">Plugins</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/compilation-times\">Improving Compilation Times</a></li>\n</ul>\n<h1>The State Platform</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/intro\">Understanding state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/build\">Build-time state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/request\">Request-time state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/revalidation\">Revalidation</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/incremental\">Incremental generation</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/amalgamation\">State amalgamation</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/browser\">Using state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/global\">Global state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/helper\">Helper state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/suspense\">Suspended state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/freezing-thawing\">Freezing and thawing</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/manual\">Manually implementing <code>ReactiveState</code></a></li>\n</ul>\n<h1>Capsules</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/capsules/intro\">Introduction</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/capsules/using\">Using capsules</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/capsules/capsules-vs-components\">Capsules vs. components</a></li>\n</ul>\n<h1>Miscellaneous</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/migrating\">Migrating from v0.3.x</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/faq\">Common pitfalls and FAQs</a></li>\n</ul>\n","status":"Next","title":"Build-time state"},"head":"<title>Build-time state | Perseus Docs</title><link rel=\"stylesheet\" href=\".perseus/static/styles/markdown.css\"/><link rel=\"stylesheet\" href=\".perseus/static/styles/docs_links_markdown.css\"/><link rel=\"stylesheet\" href=\".perseus/static/prism.css\"/>"}