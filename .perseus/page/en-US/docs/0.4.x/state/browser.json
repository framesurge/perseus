{"state":{"content":"<h1>Using state</h1>\n<p>Most of this section has been devoted to methods of generating state, but what about actually <em>using</em> it in views? This is actually a complex subject, mainly because of how Perseus handles the difference between reactive and unreactive state.</p>\n<h2>The flow of state</h2>\n<p>Once your state has been generated on the engine-side, at build-time, request-time, whatever, it will be used to render the HTML of your page in advance (as early as possible). This will produce an HTML fragment, which will be interpolated into the index view of your app, with a few variables set (including a JSON representation of your state, which can be used in hydration). This is then sent to the browser, where <a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/fundamentals/hydration\">hydration</a> occurs and your state is deserialized into your state type.</p>\n<p>From here, things get a bit more complicated, because of the reactive state system. The simplest thing possible would be for your deserialized state to go straight to your page, but Perseus intervenes here. All state types in Perseus must implement four traits: <code>Serialize</code> and <code>Deserialize</code> (from Serde, to allow turning them into JSON and back again), <code>Clone</code> (for some internal mechanics, but this is used sparingly), and <code>MakeRx</code>. Now, this fourth one definitely qualifies as implementation details, and you don't need to know how this works to use it, but a lot of Rust developers like to know what's going on behind the scenes, so here you go!</p>\n<p>When you derive <code>ReactiveState</code>, what that macro does is create an implementation of <code>MakeRx</code> that takes each field of your state and wraps it in an <a href=\"https://docs.rs/sycamore/0.4/sycamore/reactive/struct.RcSignal.html\"><code>RcSignal</code></a>, from Sycamore, which makes it <em>reactive</em>, meaning you can run <code>.get()</code> and <code>.set()</code> on it. This reactive version is named according to the <code>#[rx(alias = &quot;..&quot;)]</code> derive macro helper that you provide. Then, this reactive version has <code>MakeUnrx</code> implemented on it, which allows it to be turned back into its unreactive version. There are also some more special traits involved with <a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/state/freezing\">state freezing</a>, but that will be dealt with later.</p>\n<details>\n<summary>How does unreactive state work?</summary>\n<p>The <code>MakeRx</code> implementation just creates a wrapper that isn't really reactive, and the <code>MakeUnrx</code> implementation just removes that wrapper. Yeah, it's that simple.</p>\n</details>\n<p>Once Perseus has made your state reactive, it will store it in the <em>state store</em>, which is pretty much a giant repository of all the states your app has. As a user visits a new page, its state will be added to this cache, allowing that page to be re-rendered later without any network requests. This can be thought of as the caching equivalent of SPA routing (if you're familiar with that), and it allows Perseus to ensure a seamless experience for your users. The number of pages that can be in the state store at any one time is 25 by default (but this may change in a future release), and you can it manually with the <code>.pss_max_size()</code> method on your <code>PerseusApp</code>.</p>\n<p>Because Perseus makes your state reactive, <em>and then</em> stores it in the state store (abbreviated PSS for Perseus state store, since the alternative is quite unsavoury), any updates your pages make to their state will be reflected in this cache, meaning that, when users come back to, say, a pahge whose state included some form inputs, those inputs will be as they left them, without needing to rely on the browser to provide this. We strongly believe this behavior should be the default for the web, and it's built into Perseus. (If you'd like to avoid it though, you can always use unreactive state, or use <code>Signal</code>s manually that aren't checked into Perseus.)</p>\n<p>When the user goes to a page they've already visited in the past, Perseus will try to find the cached state in the PSS, and it will use that if it can. Otherwise, it will request the state only (no HTML) from the server, and then cache it.</p>\n<h2>Using reactive state</h2>\n<p>When you're writing views that don't take state, the function signatures are very simple: just accept a Sycamore scope, and return a <code>View&lt;G&gt;</code>. But, when there's state involved, things get <em>way</em> more complicated. Most of the time, you'll write something like this:</p>\n<pre><code class=\"language-rust\">#[auto_scope]\nfn my_view&lt;G: Html&gt;(cx: Scope, state: &amp;MyStateRx) -&gt; View&lt;G&gt;\n</code></pre>\n<p>This is made possible by the <code>#[auto_scope]</code> macro, which rewrites this function signature into something much more complicated with lifetimes everywhere:</p>\n<pre><code class=\"language-rust\">fn my_view&lt;'page, G: Html&gt;(cx: BoundedScope&lt;'_, 'page&gt;, state: &amp;'page MyStateRx) -&gt; View&lt;G&gt; \n</code></pre>\n<p>So let's break this down. We've gone from <code>Scope</code> to <code>BoundedScope</code>, which is an important difference. Basically, a <code>BoundedScope</code> is the fundamental primitive in Sycamore: it takes the lifetime of some root-level scope, and then the lifetime of itself. The reason for this is that, in Sycamore, you can have <em>child scopes</em>: so, in Perseus, the first lifetime is <code>'app</code>, and the second is <code>'page</code>, where the app will outlive the page. <code>Scope</code> is actually just an alias for a special type of <code>BoundedScope</code> where the lifetimes are the same, but it's much easier to write, so <code>#[auto_scope]</code> lets you do that. Notice that the <code>'app</code> lifetime can be elided, and Rust will figure this out itself.</p>\n<p>The next thing is that the state is borrowed for the lifetime of the page, which might not make sense at first: don't you want it to live as long as the app if it's in some cache? Well, this gets to the idea of Perseus being a <em>framework</em>, not a <em>library</em>. Perseus is in charge of your state, so the cache actually comes first. The cache is what has the owned copy of the state, and you get a reference. Since the reactive version of your state is all <code>RcSignal</code>s anyway, there's no cost to <code>Clone</code>ing it, but, if we use a reference with the same lifetime as the page, Sycamore's <code>view!</code> macro can understand that it's safe to interpolate the state anywhere we want: it is <em>guaranteed</em> through Rust's type system to live as long as the page. This avoids all sorts of nasty lifetime errors, as anyone who used Sycamore before v0.8 can attest to!</p>\n<p>Note that it's perfectly fine for you to write out the full lifetime bounds if you want to, the <code>#[auto_scope]</code> macro just exists for convenience. If you don't like the magic of it, you don't have to use it at all. (In fact, you don't have to use <em>any</em> of Perseus' macros if you don't want, and you can even disable them altogether, they're gated by the <code>macros</code> feature, which is enabled by default.)</p>\n<h2>Unreactive state</h2>\n<p>When you're using unreactive state, none of this is necessary, because Perseus just gives you an owned copy of your state to do with as you please, and you don't need <code>#[auto_scope]</code> or any special lifetimes. (You can even use a normal <code>Scope</code>, which is a white lie to Rust's type system, but it's totally immaterial to the output, so it's a useful elision.)</p>\n<p>Note that it's often a good idea to use unreactive state, even if you think you may as well use reactive state, because it gives you the added benefit of automatically being excluded from Perseus' HSR system, which means that, when you change some unreactive state in development, and your browser automatically reloads after rebuilding, that state will be reflected, rather than the old version. If you did this with reactive state, you'd find the old state again, because Perseus would try to be helpful by restoring it. Of course, you could get to the new stuff by just reloading the page, but this is inconvenient for some state types (e.g. the contents of a blog post that you want to preview by continually changing with <code>perseus serve -w</code> running). The same effect of HSR ignoring can be achieved by adding <code>#[rx(hsr_ignore)]</code> to any reacctive state type in your app, just below <code>#[rx(alias = &quot;..&quot;)]</code>. This will have no impact on anything other than HSR, and your app will function exactly as you'd expect, just with a little more convenience. Of course, if you're continually changing some reactive state for debugging or the like, you might like to temporarily add this helper macro for your own convenience. At this stage, Perseus does not support excluding single fields from HSR (although this <em>may</em> be supported in future if there is sufficient demand).</p>\n<h2>Nested state</h2>\n<p>When you're using the <code>ReactiveState</code> derive macro, it's common to want to have some types use nested state, so that you can do something like <code>state.foo.bar.get()</code>, rather than <code>state.foo.get().bar</code>. This can enable greater flexibility and granularity, and is supported through the <code>#[rx(nested)]</code> helper macro, which will assume the type of the field it annotates has had <code>ReactiveState</code> derived on it. </p>\n<p>If you want to use some more complex types of nested state, such as nested <code>Vec</code>s or <code>HashMap</code>s, take a look at <a href=\"https://docs.rs/perseus/0.4/perseus/state/rx_collections.html\">this module</a>, and enable the <code>rx-collections</code> feature flag on Perseus.</p>\n<p>Note that it's not necessary to specify <code>#[rx(hsr_ignore)]</code> on all nested state types when you want to exclude one state from HSR, you can just specify it at the top-level. Asking Perseus to ignore a nested field from HSR will have no effect, as it only checks the top level during HSR thawing.</p>\n","current_version":"0.4.x","manifest":{"0.1.x":{"docs_rs":"0.1","git":"v0.1.4","state":"outdated"},"0.2.x":{"docs_rs":"0.2","git":"v0.2.3","state":"outdated"},"0.3.0-0.3.3":{"docs_rs":"0.3.3","git":"v0.3.3","state":"outdated"},"0.3.4":{"docs_rs":"0.3","git":"v0.3.6","state":"outdated"},"0.4.x":{"docs_rs":"0.4","git":"HEAD","state":"stable"}},"sidebar_content":"<h1>Introduction</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/intro\">Introduction</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/quickstart\">Quickstart</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/what-is-perseus\">What is Perseus?</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/core-principles\">Core Principles</a></li>\n</ul>\n<h1>Your First App</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/first-app/installation\">Installing Perseus</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/first-app/defining\">Defining your app</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/first-app/generating-pages\">Generating pages</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/first-app/dev-cycle\">Development cycle</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/first-app/error-handling\">Error handling</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/first-app/deploying\">Deploying your app</a></li>\n</ul>\n<h1>Fundamentals</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/fundamentals/perseus-app\"><code>PerseusApp</code></a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/fundamentals/reactor\">The reactor</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/fundamentals/routing\">Routing and navigation</a>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/fundamentals/preloading\">Preloading</a></li>\n</ul>\n</li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/fundamentals/i18n\">Internationalization</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/fundamentals/error-views\">Error views</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/fundamentals/hydration\">Hydration</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/fundamentals/static-content\">Static content</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/fundamentals/head-headers\">Heads and headers</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/fundamentals/styling\">Styling</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/fundamentals/js-interop\">Working with JS</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/fundamentals/serving-exporting\">Servers and exporting</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/fundamentals/debugging\">Debugging</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/fundamentals/testing\">Writing tests</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/fundamentals/plugins\">Plugins</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/fundamentals/compilation-times\">Improving Compilation Times</a></li>\n</ul>\n<h1>The State Platform</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/state/intro\">Understanding state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/state/build\">Build-time state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/state/request\">Request-time state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/state/revalidation\">Revalidation</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/state/incremental\">Incremental generation</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/state/amalgamation\">State amalgamation</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/state/browser\">Using state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/state/global\">Global state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/state/helper\">Helper state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/state/suspense\">Suspended state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/state/freezing-thawing\">Freezing and thawing</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/state/manual\">Manually implementing <code>ReactiveState</code></a></li>\n</ul>\n<h1>Capsules</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/capsules/intro\">Introduction</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/capsules/using\">Using capsules</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/capsules/capsules-vs-components\">Capsules vs. components</a></li>\n</ul>\n<h1>Miscellaneous</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/migrating\">Migrating from v0.3.x</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.4.x/faq\">Common pitfalls and FAQs</a></li>\n</ul>\n","status":"Stable","title":"Using state"},"head":"<title>Using state | Perseus Docs</title><link rel=stylesheet href=.perseus/static/styles/markdown.css><link rel=stylesheet href=.perseus/static/styles/docs_links_markdown.css><link rel=stylesheet href=.perseus/static/prism.css>"}