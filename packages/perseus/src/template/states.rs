use crate::errors::*;
use crate::state::TemplateState;

/// Represents all the different states that can be generated for a single
/// template, allowing amalgamation logic to be run with the knowledge
/// of what did what (rather than blindly working on a vector).
#[derive(Debug)]
pub(crate) struct States {
    /// Any state generated by the *build state* strategy.
    pub build_state: TemplateState,
    /// Any state generated by the *request state* strategy.
    pub request_state: TemplateState,
}
impl States {
    /// Checks if both request state and build state are defined.
    pub fn both_defined(&self) -> bool {
        !self.build_state.is_empty() && !self.request_state.is_empty()
    }
    /// Gets the only defined state if only one is defined. If no states are
    /// defined, this will just return `None`. If both are defined,
    /// this will return an error. (Under no other conditions may this
    /// ever return an error.)
    pub fn get_defined(&self) -> Result<TemplateState, ServeError> {
        if self.both_defined() {
            return Err(ServeError::BothStatesDefined);
        }

        if !self.build_state.is_empty() {
            Ok(self.build_state.clone())
        } else if !self.request_state.is_empty() {
            Ok(self.request_state.clone())
        } else {
            Ok(TemplateState::empty())
        }
    }
}
