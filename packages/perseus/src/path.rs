use serde::{Deserialize, Serialize};
use std::ops::Deref;

/// A path that includes no locale, and no template/capsule name. For the page
/// `/posts/foo` generated by the `posts` template, the [`PurePath`] would be
/// `foo`.
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
#[serde(transparent)]
pub struct PurePath(pub String);
impl Deref for PurePath {
    type Target = String;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
/// A path that includes the locale, whether the app is using i18n or not.
/// If i18n is not being used, the locale will be `xx-XX`.
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
#[serde(transparent)]
pub struct PathWithLocale(pub String);
impl Deref for PathWithLocale {
    type Target = String;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
/// A path that does not include the locale, even if the app is using i18n.
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
#[serde(transparent)]
pub struct PathWithoutLocale(pub String);
impl Deref for PathWithoutLocale {
    type Target = String;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
/// A path that will include the locale if the app is using i18n, and that will
/// not if it isn't.
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
#[serde(transparent)]
pub struct PathMaybeWithLocale(pub String);
impl Deref for PathMaybeWithLocale {
    type Target = String;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl PathMaybeWithLocale {
    /// Creates a new instance of [`PathMaybeWithLocale`] from the given
    /// [`PathWithoutLocale`] and locale.
    pub fn new(path_without_locale: &PathWithoutLocale, locale: &str) -> Self {
        Self(match locale {
            "xx-XX" => path_without_locale.to_string(),
            locale => format!("{}/{}", locale, path_without_locale.0),
        })
    }
}
