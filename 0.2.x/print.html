<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Perseus Book</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="what-is-perseus.html"><strong aria-hidden="true">1.1.</strong> What is Perseus?</a></li><li class="chapter-item expanded "><a href="hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello World!</a></li></ol></li><li class="chapter-item expanded "><a href="second-app.html"><strong aria-hidden="true">2.</strong> Your Second App</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="define-app.html"><strong aria-hidden="true">3.</strong> define_app!</a></li><li class="chapter-item expanded "><a href="views.html"><strong aria-hidden="true">4.</strong> Writing Views</a></li><li class="chapter-item expanded "><a href="debugging.html"><strong aria-hidden="true">5.</strong> Debugging</a></li><li class="chapter-item expanded "><a href="templates/intro.html"><strong aria-hidden="true">6.</strong> Templates and Routing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="templates/metadata-modification.html"><strong aria-hidden="true">6.1.</strong> Modifying the &lt;head&gt;</a></li><li class="chapter-item expanded "><a href="templates/setting-headers.html"><strong aria-hidden="true">6.2.</strong> Modifying HTTP Headers</a></li></ol></li><li class="chapter-item expanded "><a href="error-pages.html"><strong aria-hidden="true">7.</strong> Error Pages</a></li><li class="chapter-item expanded "><a href="static-content.html"><strong aria-hidden="true">8.</strong> Static Content</a></li><li class="chapter-item expanded "><a href="i18n/intro.html"><strong aria-hidden="true">9.</strong> Internationalization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="i18n/defining.html"><strong aria-hidden="true">9.1.</strong> Defining Translations</a></li><li class="chapter-item expanded "><a href="i18n/using.html"><strong aria-hidden="true">9.2.</strong> Using Translations</a></li><li class="chapter-item expanded "><a href="i18n/translations-managers.html"><strong aria-hidden="true">9.3.</strong> Translations Managers</a></li><li class="chapter-item expanded "><a href="i18n/other-engines.html"><strong aria-hidden="true">9.4.</strong> Other Translation Engines</a></li></ol></li><li class="chapter-item expanded "><a href="strategies/intro.html"><strong aria-hidden="true">10.</strong> Rendering Strategies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="strategies/build-state.html"><strong aria-hidden="true">10.1.</strong> Build State</a></li><li class="chapter-item expanded "><a href="strategies/build-paths.html"><strong aria-hidden="true">10.2.</strong> Build Paths</a></li><li class="chapter-item expanded "><a href="strategies/request-state.html"><strong aria-hidden="true">10.3.</strong> Request State</a></li><li class="chapter-item expanded "><a href="strategies/revalidation.html"><strong aria-hidden="true">10.4.</strong> Revalidation</a></li><li class="chapter-item expanded "><a href="strategies/incremental.html"><strong aria-hidden="true">10.5.</strong> Incremental Generation</a></li><li class="chapter-item expanded "><a href="strategies/amlagamation.html"><strong aria-hidden="true">10.6.</strong> State Amalgamation</a></li></ol></li><li class="chapter-item expanded "><a href="cli.html"><strong aria-hidden="true">11.</strong> CLI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ejecting.html"><strong aria-hidden="true">11.1.</strong> Ejecting</a></li></ol></li><li class="chapter-item expanded "><a href="config-managers.html"><strong aria-hidden="true">12.</strong> Config Managers</a></li><li class="chapter-item expanded "><a href="testing/intro.html"><strong aria-hidden="true">13.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="testing/checkpoints.html"><strong aria-hidden="true">13.1.</strong> Checkpoints</a></li><li class="chapter-item expanded "><a href="testing/fantoccini-basics.html"><strong aria-hidden="true">13.2.</strong> Fantoccini Basics</a></li><li class="chapter-item expanded "><a href="testing/manual.html"><strong aria-hidden="true">13.3.</strong> Manual Testing</a></li></ol></li><li class="chapter-item expanded "><a href="styling.html"><strong aria-hidden="true">14.</strong> Styling</a></li><li class="chapter-item expanded "><a href="deploying/intro.html"><strong aria-hidden="true">15.</strong> Deploying</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="deploying/exporting.html"><strong aria-hidden="true">15.1.</strong> Static Exporting</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.2.</strong> Server Deployment</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.3.</strong> Serverless Deployment</div></li></ol></li><li class="chapter-item expanded "><a href="updating.html"><strong aria-hidden="true">16.</strong> Migrating from v0.1.x</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Advanced</li><li class="chapter-item expanded "><a href="advanced/intro.html"><strong aria-hidden="true">17.</strong> Under the Hood</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced/arch.html"><strong aria-hidden="true">17.1.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="advanced/initial-loads.html"><strong aria-hidden="true">17.2.</strong> Initial Loads</a></li><li class="chapter-item expanded "><a href="advanced/subsequent-loads.html"><strong aria-hidden="true">17.3.</strong> Subsequent Loads</a></li><li class="chapter-item expanded "><a href="advanced/routing.html"><strong aria-hidden="true">17.4.</strong> Routing</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Perseus Book</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome-to-perseus"><a class="header" href="#welcome-to-perseus">Welcome to Perseus!</a></h1>
<p><a href="https://github.com/arctic-hen7/perseus">Home</a> ‚Ä¢ <a href="https://crates.io/crates/perseus">Crate Page</a> ‚Ä¢ <a href="https://docs.rs/perseus">API Documentation</a> ‚Ä¢ <a href="./CONTRIBUTING.html">Contributing</a></p>
<p>Welcome to the Perseus documentation! Here, you'll find guides on how to use Perseus, as well as documentation for specific features and plenty of examples! Note that every code snippet in this book comes from something in the <a href="https://github.com/arctic-hen7/perseus/tree/main/examples">examples</a>, where you can get context from real-world code.</p>
<p>If you like Perseus, please consider giving us a star <a href="https://github.com/arctic-hen7/perseus">on GitHub</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-perseus"><a class="header" href="#what-is-perseus">What is Perseus?</a></h1>
<p>If you're familiar with <a href="https://nextjs.org">NextJS</a>, Perseus is that for Wasm. If you're familiar with <a href="https://kit.svelte.dev">SvelteKit</a>, it's that for <a href="https://github.com/sycamore-rs/sycamore">Sycamore</a>.</p>
<p>If none of that makes any sense, this is the section for you! If you're not in the mood for a lecture, <a href="what-is-perseus.html#summary">here's a TL;DR</a>!</p>
<h3 id="rust-web-development"><a class="header" href="#rust-web-development">Rust web development</a></h3>
<p><a href="https://www.rust-lang.org/">Rust</a> is an extremely powerful programming language, but I'll leave the introduction of it <a href="https://www.rust-lang.org/">to its developers</a>.</p>
<p><a href="https://webassembly.org">WebAssembly</a> (abbreviated Wasm) is like a low-level programming language for your browser. This is revolutionary, because it allows websites and web apps to be built in programming languages other than JavaScript. Also, it's <a href="https://medium.com/@torch2424/webassembly-is-fast-a-real-world-benchmark-of-webassembly-vs-es6-d85a23f8e193">really fast</a> (usually &gt;30% faster than JS).</p>
<p>But developing directly for the web with Rust using something like <a href="https://docs.rs/web-sys"><code>web-sys</code></a> isn't a great experience, it's generally agreed in the web development community that developer experience and productivity are vastly improved by having a <em>reactive</em> framework. Let's approach this from a traditional JavaScript and HTML perspective first.</p>
<p>Imagine you want to create a simple counter. Here's how you might do it in a non-reactive framework (again, JS and HTML here, no Rust yet):</p>
<pre><code class="language-html">&lt;p id=&quot;counter&quot;&gt;0&lt;/p&gt;&lt;br/&gt;
&lt;button onclick=&quot;document.getElementById('counter').innerHTML = parseInt(document.getElementById('counter').innerHTML) + 1&quot;&gt;Increment&lt;/button&gt;
</code></pre>
<p>If you're unfamiliar with HTML and JS, don't worry. All this does is create a paragraph with a number inside and then increment it. But the problem is clear in terms of expression: why can't we just put a variable in the paragraph and have that re-render when we increment that variable? Well, that's reactivity!</p>
<p>In JS, there are frameworks like <a href="https://svelte.dev">Svelte</a> and <a href="https://reactjs.org">ReactJS</a> that solve this problem, but they're all bound significantly by the language itself. JavaScript is slow, dynamically typed, and <a href="https://medium.com/netscape/javascript-is-kinda-shit-im-sorry-2e973e36fec4">a bit of a mess</a>. Like all things to do with the web, changing things is really difficult because people have already started using them, and there will always be <em>someone</em> still using Internet Explorer, which supports almost no modern web standards at all.</p>
<p><a href="https://webassembly.org">Wasm</a> solves all these problems by creating a unified format that other programming languages, like Rust, can compile into for the browser environment. This makes websites safer, faster, and development more productive. The equivalent of these reactive frameworks for Rust in particular would be projects like <a href="https://sycamore-rs.netlify.app">Sycamore</a>, <a href="https://seed-rs.org">Seed</a>, and <a href="https://yew.rs">Yew</a>. Sycamore is the most extensible and low-level of those options, and it's more performant because it doesn't use a <a href="https://svelte.dev/blog/virtual-dom-is-pure-overhead">virtual DOM</a> (link about JS rather than Rust), and so it was chosen to be the backbone of Perseus. Here's what that counter might look like in <a href="https://sycamore-rs.netlify.app">Sycamore</a> (the incrementation has been moved into a new closure for convenience):</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sycamore::prelude::*;

let counter = Signal::new(0);
let increment = cloned!((counter) =&gt; move |_| counter.set(*counter.get() + 1));

template! {
    p { (counter.get()) }
    button(on:click = increment) { &quot;Increment&quot; }
}
<span class="boring">}
</span></code></pre></pre>
<p>You can learn more about Sycamore's amazing systems <a href="https://sycamore-rs.netlify.app">here</a>.</p>
<h3 id="this-sounds-good"><a class="header" href="#this-sounds-good">This sounds good...</a></h3>
<p>But there's a catch to all this: rendering. With all these approaches in Rust so far (except for a few mentioned later), all your pages are rendered <em>in the user's browser</em>. That means your users have to download your Wasm code and run it before they see anything at all on their screens. Not only does that increase your loading time (<a href="https://medium.com/@vikigreen/impact-of-slow-page-load-time-on-website-performance-40d5c9ce568a">which can drive away users</a>), it reduces your search engine rankings as well.</p>
<p>This can be solved through <em>server-side rendering</em> (SSR), which means that we render pages on the server and send them to the client, which means your users see something very quickly, and then it becomes <em>interactive</em> (usable) a moment later. This is better for user retention (shorter loading times) and SEO (search engine optimization).</p>
<p>The traditional approach to SSR is to wait for a request for a particular page (say <code>/about</code>), and then render it on the server and send that to the client. This is what <a href="https://seed-rs.org">Seed</a> (an alternative to Perseus) does. However, this means that your website's <em>time to first byte</em> (TTFB) is slower, because the user won't even get <em>anything</em> from the server until it has finished rendering. In times of high load, that can drive loading times up worryingly.</p>
<p>The solution to this is <em>static site generation</em> (SSG), whereby your pages are rendered <em>at build time</em>, and they can be served almost instantly on any request. This approach is fantastic, and thus far widely unimplemented in Rust. The downside to this is that you don't get as much flexibility, because you have to render everything at build time. That means you don't have access to any user credentials or anything else like that. Every page you render statically has to be the same for every user.</p>
<p>Perseus supports SSR <em>and</em> SSG out of the box, along with the ability to use both on the same page, rebuild pages after a certain period of time (e.g. to update a list of blog posts every 24 hours) or based on certain conditions (e.g. if the hash of a file has changed), or even to statically build pages on demand (the first request is SSR, all the rest are SSG), meaning you can get the best of every world and faster build times.</p>
<p>To our knowledge, the only other framework in the world right now that supports this feature set is <a href="https://nextjs.org">NextJS</a> (with growing competition from <a href="https://www.gatsbyjs.com">GatsbyJS</a>), which only works with JavaScript. Perseus goes above and beyond this for Wasm by supporting whole new combinations of rendering options not previously available, allowing you to create optimized websites and web apps extremely efficiently.</p>
<h2 id="how-fast-is-it"><a class="header" href="#how-fast-is-it">How fast is it?</a></h2>
<p><a href="https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts-results/table.html">Benchmarks show</a> that <a href="https://sycamore-rs.netlify.app">Sycamore</a> is slightly faster than <a href="https://svelte.dev">Svelte</a> in places, one of the fastest JS frameworks ever. Perseus uses it and <a href="https://actix.rs">Actix Web</a>, one of the fastest web servers in the world. Essentially, Perseus is built on the fastest tech and is itself made to be fast.</p>
<p>Right now, Perseus is undergoing major improvements to make it even faster and to introduce new features, like support for internationalization (making your app available in many languages) out of the box, which involves significant changes to the code. Once these are ready, benchmarks for Perseus itself will be written to show how fast Perseus really is, but right now none exist.</p>
<h2 id="how-convenient-is-it"><a class="header" href="#how-convenient-is-it">How convenient is it?</a></h2>
<p>Perseus aims to be more convenient than any other Rust web framework by taking an approach similar to that of <a href="https://reactjs.org">ReactJS</a>. Perseus itself is an extremely complex system consisting of many moving parts that can all be brought together to create something amazing, but the vast majority of apps don't need all that customizability, so we built a command-line interface (CLI) that handles all that complexity for you, allowing you to focus entirely on your app's code.</p>
<p>Basically, here's your workflow:</p>
<ol>
<li>Create a new project.</li>
<li>Define your app in around 12 lines of code and some listing.</li>
<li>Code your amazing app.</li>
<li>Run <code>perseus serve</code>.</li>
</ol>
<h2 id="how-stable-is-it"><a class="header" href="#how-stable-is-it">How stable is it?</a></h2>
<p>Okay, there had to be one caveat! Perseus is <em>very</em> new, and as such can't be recommended for <em>production</em> usage yet. However, we're aiming to get it ready for that really soon, which will hopefully include even being able to deploy Perseus with <a href="https://en.wikipedia.org/wiki/Serverless_computing">serverless functions</a>, the step beyond a server!</p>
<p>For now though, Perseus is perfect for anything that doesn't face the wider internet, like internal tools, personal projects, or the like. Just don't use it to run a nuclear power plant, okay?</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>If all that was way too long, here's a quick summary of what Perseus does and why it's useful!</p>
<ul>
<li>JS is slow and a bit of a mess, <a href="https://webassembly.org">Wasm</a> lets you run most programing languages, like Rust, in the browser, and is really fast</li>
<li>Doing web development without reactivity is really annoying, so <a href="https://sycamore-rs.netlify.app">Sycamore</a> is great</li>
<li>Perseus lets you render your app on the server, making the client's experience <em>really</em> fast, and adds a ton of features to make that possible, convenient, and productive (even for really complicated apps)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World!</a></h1>
<p>Let's get started with Perseus!</p>
<p><em>To follow along here, you'll want to be familiar with Rust, which you can learn more about <a href="https://rust-lang.org">here</a>. You should also have it and <code>cargo</code> installed.</em></p>
<p>To begin, create a new folder for your project, let's call it <code>my-perseus-app</code>. Now, create a <code>Cargo.toml</code> file in that folder. This tells Rust which packages you want to use in your project and some other metadata. Put the following inside:</p>
<pre><code class="language-toml">[package]
name = &quot;my-perseus-app&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
perseus = &quot;0.2&quot;
sycamore = &quot;0.6&quot;
</code></pre>
<details>
<summary>What are those dependencies doing?</summary>
<ul>
<li><code>perseus</code> -- the core module for Perseus</li>
<li><a href="https://github.com/sycamore-rs/sycamore"><code>sycamore</code></a> -- the amazing system on which Perseus is built, this allows you to write reactive web apps in Rust</li>
</ul>
<p>Note that we've set these dependencies up so that they'll automatically update <em>patch versions</em>, which means we'll get bug fixes automatically, but we won't get any updates that will break our app!</p>
</details>
<p>Now, create an <code>index.html</code> file at the root of your project and put the following inside:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
        &lt;title&gt;Perseus Example ‚Äì Tiny&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<details>
<summary>Why do I need an HTML file?</summary>
<p>Perseus aims to be as versatile as possible, and so it allows you to include your own <code>index.html</code> file, in which you can import things like fonts, analytics, etc.</p>
<p>This file MUST contain at least the following:</p>
<ul>
<li><code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code>, which is where your app will be rendered, this must be a <code>&lt;div&gt;</code> with no other attributes except the <code>id</code>, and that spacing (that way parsing is lightweight and fast)</li>
<li>A <code>&lt;head&gt;</code>, which is where HTML metadata goes (even if you don't have any metadata, Perseus still needs it)</li>
</ul>
<p>Note also that we don't have to import anything to make Perseus run here, the server will do that automatically for us!</p>
</details>
<p>Now, create a new directory called <code>src</code> and add a new file inside called <code>lib.rs</code>. Put the following inside:</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perseus::{define_app, ErrorPages, Template};
use std::rc::Rc;
use sycamore::template;
define_app! {
    templates: [
        Template::&lt;G&gt;::new(&quot;index&quot;).template(Rc::new(|_| {
            template! {
                p { &quot;Hello World!&quot; }
            }
        }))
    ],
    error_pages: ErrorPages::new(Rc::new(|url, status, err, _| {
        template! {
            p { (format!(&quot;An error with HTTP code {} occurred at '{}': '{}'.&quot;, status, url, err)) }
        }
    }))
}
<span class="boring">}
</span></code></pre></pre>
<details>
<summary>How does that work?</summary>
<p>First, we import some things that'll be useful:</p>
<ul>
<li><code>perseus::{define_app, ErrorPages, Template}</code> -- the -<code>define_app!</code> macro, which tells Perseus how your app works; the <code>ErrorPages</code> <code>struct</code>, which lets you tell Perseus how to handle errors (like <em>404 Not Found</em> if the user goes to a nonexistent page); and the <code>Template</code> <code>struct</code>, which is how Perseus manages pages in your app</li>
<li><code>std::rc::Rc</code> -- a <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html">reference-counted smart pointer</a> (you don't <em>have</em> to understand these to use Perseus, but reading that link would be helpful)</li>
<li><code>sycamore::template</code> -- Sycamore's [<code>template!</code> macro], which lets you write HTML-like code in Rust</li>
</ul>
<p>Then, we use the <code>define_app!</code> macro to declare the different aspects of the app, starting with the <em>templates</em>. We only have one template, which we've called <code>index</code> (a special name that makes it render at the root of your app), and then we define how that should look, creating a paragraph (<code>p</code>) containing the text <code>Hello World!</code>. Perseus does all kinds of clever stuff with this under the hood, and we put it in an <code>Rc</code> to enable that.</p>
<p>Finally, we tell Perseus what to do if something in your app fails, like if the user goes to a page that doesn't exist. This requires creating a new instance of <code>ErrorPages</code>, which is a <code>struct</code> that lets you define a separate error page for every <a href="https://httpstatuses.com">HTTP status code</a>, as well as a fallback. Here, we've just defined the fallback. That page is given the URL that caused the error, the HTTP status code, and the actual error message, all of which we display with a Sycamore <code>template!</code>, with seamless interpolation.</p>
</details>
<p>Now install the Perseus CLI with <code>cargo install perseus-cli</code> (you'll need <code>wasm-pack</code> to let Perseus build your app, use <code>cargo install wasm-pack</code> to install it) to make your life way easier, and deploy your app to <a href="http://localhost:8080">http://localhost:8080</a> by running <code>perseus serve</code> inside the root of your project! This will take a while the first time, because it's got to fetch all your dependencies and build your app.</p>
<details>
<summary>Why do I need a CLI?</summary>
<p>Perseus is a <em>very</em> complex system, and, if you had to write all that complexity yourself, that <em>Hello World!</em> example would be more like 1700 lines of code than 17! The CLI lets you abstract away all that complexity into a directory that you might have noticed appear called <code>.perseus/</code>. If you take a look inside, you'll actually find two crates (Rust packages): one for your app, and another for the server that serves your app. These are what actually run your app, and they import the code you've written. The <code>define_app!</code> macro defines a series of functions and constants at compile-time that make this possible.</p>
<p>When you run <code>perseus serve</code>, the <code>.perseus/</code> directory is created and added to your <code>.gitignore</code>, and then three stages occur in parallel (they're shown in your terminal):</p>
<ul>
<li><em>üî® Generating your app</em> -- here, your app is built to a series of static files in <code>.perseus/dist/static</code>, which makes your app lightning-fast (your app's pages are ready before it's even been deployed, which is called <em>static site generation</em>, or SSG)</li>
<li><em>üèóÔ∏è Building your app to Wasm</em> -- here, your app is built to <a href="">WebAssembly</a>, which is what lets a low-level programming language like Rust run in the browser</li>
<li><em>üì° Building server</em> -- here, Perseus builds its internal server based on your code, and prepares to serve your app</li>
</ul>
<p>The first time you run this command, it can take quite a while to get everything ready, but after that it'll be really fast. And, if you haven't changed any code (<em>at all</em>) since you last ran it, you can run <code>perseus serve --no-build</code> to run the server basically instantaneously.</p>
</details>
<p>Once that's done, hop over to <a href="http://localhost:8080">http://localhost:8080</a> in any modern browser (not Internet Explorer...), and you should see <em>Hello World!</em> printed on the screen! If you try going to <a href="http://localhost:8080/about">http://localhost:8080/about</a> or any other page, you should see a message that tells you the page wasn't found.</p>
<p>Congratulations! You've just created your first ever Perseus app! You can see the source code for this section <a href="https://github.com/arctic-hen7/perseus/tree/main/examples/tiny">here</a>.</p>
<h2 id="moving-forward"><a class="header" href="#moving-forward">Moving Forward</a></h2>
<p>The next section creates a slightly more realistic app with more than just one file, which will show you how a Perseus app is usually structured.</p>
<p>After that, you'll learn how different features of Perseus work, like <em>incremental generation</em> (which lets you build pages on-demand at runtime)!</p>
<h3 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h3>
<p>If you've gone through this and you aren't that chuffed with Perseus, here are some similar projects in Rust:</p>
<ul>
<li><a href="https://github.com/sycamore-rs/sycamore">Sycamore</a> (without Perseus) -- <em>A reactive library for creating web apps in Rust and WebAssembly.</em></li>
<li><a href="https://github.com/yewstack/yew">Yew</a> -- <em>Rust/Wasm framework for building client web apps.</em></li>
<li><a href="https://github.com/seed-rs/seed">Seed</a> -- <em>A Rust framework for creating web apps.</em></li>
<li><a href="https://github.com/chinedufn/percy">Percy</a> -- <em>Build frontend browser apps with Rust + WebAssembly. Supports server side rendering.</em></li>
<li><a href="https://github.com/MoonZoon/MoonZoon">MoonZoon</a> -- <em>Rust Fullstack Framework.</em></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-second-app"><a class="header" href="#your-second-app">Your Second App</a></h1>
<p>This section will cover building a more realistic app than the <em>Hello World!</em> section, with proper structuring and multiple templates.</p>
<p>If learning by reading isn't really your thing, or you'd like a reference, you can see all the code in <a href="https://github.com/arctic-hen7/perseus/tree/main/examples/basic">this repository</a>!</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>Much like the <em>Hello World!</em> app, we'll start off by creating a new directory for the project, maybe <code>my-second-perseus-app</code> (or you could exercise imagination...). Then, we'll create a new <code>Cargo.toml</code> file and fill it with the following:</p>
<pre><code class="language-toml">[package]
name = &quot;my-second-perseus-app&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
perseus = &quot;0.2&quot;
sycamore = &quot;0.6&quot;
serde = { version = &quot;1&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1&quot;
</code></pre>
<p>The only difference between this and the last <code>Cargo.toml</code> we created is two new dependencies:</p>
<ul>
<li><a href="https://serde.rs"><code>serde</code></a> -- a really useful Rust library for serializing/deserializing data</li>
<li><a href="https://github.com/serde-rs/json"><code>serde_json</code></a> -- Serde's integration for JSON, which lets us pass around properties for more advanced pages in Perseus</li>
</ul>
<p>The next thing to do is to create <code>index.html</code>, which is pretty much the same as last time:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>The only notable difference here is the absence of a <code>&lt;title&gt;</code>, which is because we'll be creating it inside Perseus! Any Perseus template can modify the <code>&lt;head&gt;</code> of the document, but anything you put into <code>index.html</code> will persist across all pages. We don't want to have conflicting titles, so we leave that property out of <code>index.html</code>.</p>
<h2 id="librs"><a class="header" href="#librs"><code>lib.rs</code></a></h2>
<p>As in every Perseus app, <code>lib.rs</code> is how we communicate with the CLI and tell it how our app works. Put the following content in <code>src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust no_playground no_run edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod error_pages;
mod templates;

use perseus::define_app;

define_app! {
    templates: [
        crate::templates::index::get_template::&lt;G&gt;(),
        crate::templates::about::get_template::&lt;G&gt;()
    ],
    error_pages: crate::error_pages::get_error_pages(),
    static_aliases: {
        &quot;/test.txt&quot; =&gt; &quot;static/test.txt&quot;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This code is quite different from your first app, so let's go through how it works.</p>
<p>First, we define two other modules in our code: <code>error_pages</code> (at <code>src/error_pages.rs</code>) and <code>templates</code> (at <code>src/templates</code>). Don't worry, we'll create those in a moment. The rest of the code creates a new app with two templates, which are expected to be in the <code>src/templates</code> directory. Note the use of <code>&lt;G&gt;</code> here, which is a Rust <em>type parameter</em> (the <code>get_template</code> function can work for the browser or the server, so Rust needs to know which one it is). This parameter is <em>ambient</em> to the <code>templates</code> key, which means you can use it without declaring it as long as you're inside <code>templates: {...}</code>. This will be set to <code>DomNode</code> for the browser and <code>SsrNode</code> for the server, but that all happens behind the scenes.</p>
<p>Also note that we're pulling in our error pages from another file as well (in a larger app you may even want to have a different file for each error page).</p>
<p>The last thing we do is new, we define <code>static_aliases</code> to map the URL <code>/test.txt</code> in our app to the file <code>static/test.txt</code>. This feature is detailed in more depth later, but it can be extremely useful, for example for defining your site's logo (or favicon), which browsers expect to be available at <code>/favicon.ico</code>. Create the <code>static/test.txt</code> file now (<code>static/</code> should NOT be inside <code>src/</code>!) and fill it with whatever you want.</p>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>Before we get to the cool part of building the actual pages of the app, we should set up error pages again, which we'll do in <code>src/error_pages.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perseus::{ErrorPages, GenericNode};
use std::rc::Rc;
use sycamore::template;

pub fn get_error_pages&lt;G: GenericNode&gt;() -&gt; ErrorPages&lt;G&gt; {
    let mut error_pages = ErrorPages::new(Rc::new(|url, status, err, _| {
        template! {
            p { (format!(&quot;An error with HTTP code {} occurred at '{}': '{}'.&quot;, status, url, err)) }
        }
    }));
    error_pages.add_page(
        404,
        Rc::new(|_, _, _, _| {
            template! {
                p { &quot;Page not found.&quot; }
            }
        }),
    );

    error_pages
}
<span class="boring">}
</span></code></pre></pre>
<p>This is a little more advanced than the last time we did this, and there are a few things we should note.</p>
<p>The first is the import of <code>GenericNode</code>, which we define as a type parameter on the <code>get_error_pages</code> function. As we said before, this means your error pages will work on the client or the server, and they're needed in both environments. If you're interested, this separation of browser and server elements is done by Sycamore, and you can learn more about it <a href="https://docs.rs/sycamore/0.6/sycamore/generic_node/trait.GenericNode.html">here</a>.</p>
<p>In this function, we also define a different error page for a 404 error, which will occur when a user tries to go to a page that doesn't exist. The fallback page (which we initialize <code>ErrorPages</code> with) is the same as last time, and will be called for any errors other than a <em>404 Not Found</em>.</p>
<h2 id="indexrs"><a class="header" href="#indexrs"><code>index.rs</code></a></h2>
<p>It's time to create the first page for this app! But first, we need to make sure that import in <code>src/lib.rs</code> of <code>mod templates;</code> works, which requires us to create a new file <code>src/templates/mod.rs</code>, which declares <code>src/templates</code> as a module with its own code. Add the following to that file:</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod about;
pub mod index;
<span class="boring">}
</span></code></pre></pre>
<p>It's common practice to have a file for each <em>template</em>, which is slightly different to a page (explained in more detail later), and this app has two pages: a landing page (index) and an about page.</p>
<p>Let's begin with the landing page. Create a new file <code>src/templates/index.rs</code> and put the following inside:</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perseus::{
    http::header::{HeaderMap, HeaderName},
    GenericNode, StringResultWithCause, Template,
};
use serde::{Deserialize, Serialize};
use std::rc::Rc;
use sycamore::prelude::{component, template, Template as SycamoreTemplate};

#[derive(Serialize, Deserialize, Debug)]
pub struct IndexPageProps {
    pub greeting: String,
}

#[component(IndexPage&lt;G&gt;)]
pub fn index_page(props: IndexPageProps) -&gt; SycamoreTemplate&lt;G&gt; {
    template! {
        p {(props.greeting)}
        a(href = &quot;/about&quot;, id = &quot;about-link&quot;) { &quot;About!&quot; }
    }
}

pub fn get_template&lt;G: GenericNode&gt;() -&gt; Template&lt;G&gt; {
    Template::new(&quot;index&quot;)
        .build_state_fn(Rc::new(get_build_props))
        .template(template_fn())
        .head(head_fn())
        .set_headers_fn(set_headers_fn())
}

pub async fn get_build_props(_path: String) -&gt; StringResultWithCause&lt;String&gt; {
    Ok(serde_json::to_string(&amp;IndexPageProps {
        greeting: &quot;Hello World!&quot;.to_string(),
    })
    .unwrap())
}

pub fn template_fn&lt;G: GenericNode&gt;() -&gt; perseus::template::TemplateFn&lt;G&gt; {
    Rc::new(|props: Option&lt;String&gt;| {
        template! {
            IndexPage(
                serde_json::from_str::&lt;IndexPageProps&gt;(&amp;props.unwrap()).unwrap()
            )
        }
    })
}

pub fn head_fn() -&gt; perseus::template::HeadFn {
    Rc::new(|_| {
        template! {
            title { &quot;Index Page | Perseus Example ‚Äì Basic&quot; }
        }
    })
}

pub fn set_headers_fn() -&gt; perseus::template::SetHeadersFn {
    Rc::new(|_| {
        let mut map = HeaderMap::new();
        map.insert(
            HeaderName::from_lowercase(b&quot;x-test&quot;).unwrap(),
            &quot;custom value&quot;.parse().unwrap(),
        );
        map
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>This code is <em>much</em> more complex than the <em>Hello World!</em> example, so let's go through it carefully.</p>
<p>First, we import a whole ton of stuff:</p>
<ul>
<li><code>perseus</code>
<ul>
<li><code>StringResultWithCause</code> -- see below for an explanation of this</li>
<li><code>Template</code> -- as before</li>
<li><code>GenericNode</code> -- as before</li>
</ul>
</li>
<li><code>serde</code>
<ul>
<li><code>Serialize</code> -- a trait for <code>struct</code>s that can be turned into a string (like JSON)</li>
<li><code>Deserialize</code> -- a trait for <code>struct</code>s that can be <em>de</em>serialized from a string (like JSON)</li>
</ul>
</li>
<li><code>std::rc::Rc</code> -- same as before, you can read more about <code>Rc</code>s <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html">here</a></li>
<li><code>sycamore</code>
<ul>
<li><code>component</code> -- a macro that turns a function into a Sycamore component</li>
<li><code>template</code> -- the <code>template!</code> macro, same as before</li>
<li><code>Template as SycamoreTemplate</code> -- the output of the <code>template!</code> macro, aliased as <code>SycamoreTemplate</code> so it doesn't conflict with <code>perseus::Template</code>, which is very different</li>
</ul>
</li>
</ul>
<p>Then we define a number of different functions and a <code>struct</code>, each of which gets a section now.</p>
<h3 id="indexpageprops"><a class="header" href="#indexpageprops"><code>IndexPageProps</code></a></h3>
<p>This <code>struct</code> represents the properties that the index page will take. In this case, we're building an index page that will display a greeting defined in this, specifically in the <code>greeting</code> property.</p>
<p>Any template can take arguments in Perseus, which should always be given inside a <code>struct</code>. For simplicity and performance, Perseus only ever passes your properties around as a <code>String</code>, so you'll need to serialize/deserialize them yourself (as in the functions below).</p>
<h3 id="index_page"><a class="header" href="#index_page"><code>index_page()</code></a></h3>
<p>This is the actual component that your page is. Technically, you could just put this under <code>template_fn()</code>, but it's conventional to break it out independently. By annotating it with <code>#[component(IndexPage&lt;G&gt;)]</code>, we tell Sycamore to turn it into a complex <code>struct</code> that can be called inside <code>template!</code> (which we do in <code>template_fn()</code>).</p>
<p>Note that this takes <code>IndexPageProps</code> as an argument, which it can then access in the <code>template!</code>. This is Sycamore's interpolation system, which you can read about <a href="https://sycamore-rs.netlify.app/docs/basics/template">here</a>, but all you need to know is that it's basically seamless and works exactly as you'd expect.</p>
<p>The only other thing we do here is define an <code>&lt;a&gt;</code> (an HTML link) to <code>/about</code>. This link, and any others you define, will automatically be detected by Sycamore's systems, which will pass them to Perseus' routing logic, which means your users <strong>never leave the page</strong>. In this way, Perseus only pulls in the content that needs to change, and gives your users the feeling of a lightning-fast and weightless app.</p>
<p><em>Note: external links will automatically be excluded from this, and you can exclude manually by adding <code>rel=&quot;external&quot;</code> if you need.</em></p>
<h3 id="get_template"><a class="header" href="#get_template"><code>get_template()</code></a></h3>
<p>This function is what we call in <code>lib.rs</code>, and it combines everything else in this file to produce an actual Perseus <code>Template</code> to be used. Note the name of the template as <code>index</code>, which Perseus interprets as special, which causes this template to be rendered at <code>/</code> (the landing page).</p>
<p>Perseus' templating system is extremely versatile, and here we're using it to define our page itself through <code>.template()</code>, and to define a function that will modify the document <code>&lt;head&gt;</code> (which allows us to add a title) with <code>.head()</code>. Notably, we also use the <em>build state</em> rendering strategy, which tells Perseus to call the <code>get_build_props()</code> function when your app builds to get some state. More on that now.</p>
<h3 id="get_build_props"><a class="header" href="#get_build_props"><code>get_build_props()</code></a></h3>
<p>This function is part of Perseus' secret sauce (actually <em>open</em> sauce), and it will be called when the CLI builds your app to create properties that the template will take (it expects a string, hence the serialization). Here, we just hard-code a greeting in to be used, but the real power of this comes when you start using the fact that this function is <code>async</code>. You might query a database to get a list of blog posts, or pull in a Markdown documentation page and parse it, the possibilities are endless!</p>
<p>Note that this function returns a <code>StringResultWithCause&lt;String&gt;</code>, which means that it returns a normal Rust <code>Result&lt;String, E&gt;</code>, where <code>E</code> is a tuple of a <code>String</code> error message and a declaration of who caused the error (either the client or the server). This becomes important when you combine this rendering strategy with others, which are explained in depth later in the book.</p>
<h3 id="template_fn"><a class="header" href="#template_fn"><code>template_fn()</code></a></h3>
<p>The result of this function is what Perseus will call when it wants to render your template (which it does more than you might think), and it passes it the props that your template takes as an <code>Option&lt;String&gt;</code>. This might seem a bit weird, but there are reasons under the hood. All you need to know here is that if your template takes any properties, they <strong>will</strong> be here, and it's safe to <code>.unwrap()</code> them for deserialization.</p>
<h3 id="head_fn"><a class="header" href="#head_fn"><code>head_fn()</code></a></h3>
<p>This is very similar to <code>template_fn</code>, except it can't be reactive. In other words, anything you put in here is like a picture, it can't move (so no buttons, counters, etc.). This is because this modifies the document <code>&lt;head&gt;</code>, so you should put metadata, titles, etc. in here. Note that the function we return from here does take an argument (ignored with <code>_</code>), that's a string of the properties to your app, but we don't need it in this example. If this page was a generic template for blog posts, you might use this capability to render a different title for each blog post.</p>
<p>All this does though is set the <code>&lt;title&gt;</code>. If you inspect the source code of the HTML in your browser, you'll find a big comment in the <code>&lt;head&gt;</code> that says <code>&lt;!--PERSEUS_INTERPOLATED_HEAD_BEGINS--&gt;</code>, that separates the stuff that should remain the same on every page from the stuff that should update for each page.</p>
<h2 id="aboutrs"><a class="header" href="#aboutrs"><code>about.rs</code></a></h2>
<p>Okay! We're past the hump, and now it's time to define the (much simpler) <code>/about</code> page. Create <code>src/templates/about.rs</code> and put the following inside:</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perseus::{is_client, Template};
use std::rc::Rc;
use sycamore::prelude::{component, template, GenericNode, Template as SycamoreTemplate};

#[component(AboutPage&lt;G&gt;)]
pub fn about_page() -&gt; SycamoreTemplate&lt;G&gt; {
    template! {
        p { &quot;About.&quot; }
        p {
            (
                format!(
                    &quot;This is currently being run on the {}.&quot;,
                    if is_client!() {
                        &quot;client&quot;
                    } else {
                        &quot;server&quot;
                    }
                )
            )
        }
    }
}

pub fn get_template&lt;G: GenericNode&gt;() -&gt; Template&lt;G&gt; {
    Template::new(&quot;about&quot;)
        .template(template_fn())
        .head(head_fn())
}

pub fn template_fn&lt;G: GenericNode&gt;() -&gt; perseus::template::TemplateFn&lt;G&gt; {
    Rc::new(|_| {
        template! {
            AboutPage()
        }
    })
}

pub fn head_fn() -&gt; perseus::template::HeadFn {
    Rc::new(|_| {
        template! {
            title { &quot;About Page | Perseus Example ‚Äì Basic&quot; }
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>This is basically exactly the same as <code>index.rs</code>, except we don't have any properties to deal with, and we don't need to generate anything special at build time (but Perseus will still render this page to static HTML, ready to be served to your users).</p>
<h2 id="running-it"><a class="header" href="#running-it">Running It</a></h2>
<p><code>perseus serve</code></p>
<p>That's all. Every time you build a Perseus app, that's all you need to do.</p>
<p>Once this is finished, your app will be live at <a href="http://localhost:8080">http://localhost:8080</a>! Note that if you don't like that, you can change the host/port with the <code>HOST</code>/<code>PORT</code> environment variables (e.g. you'd want to set the host to <code>0.0.0.0</code> if you want other people on your network to be able to access your site).</p>
<p>Hop over to <a href="http://localhost:8080">http://localhost:8080</a> in any modern browser and you should see your greeting <code>Hello World!</code> above a link to the about page! if you click that link, you'll be taken to a page that just says <code>About.</code>, but notice how your browser seemingly never navigates to a new page (the tab doesn't show a loading icon)? That's Perseus' <em>app shell</em> in action, which intercepts navigation to other pages and makes it occur seamlessly, only fetching the bare minimum to make the new page load. The same behavior will occur if you use your browser's forward/backward buttons.</p>
<details>
<summary>Why a 'modern browser'?</summary>
<h3 id="browser-compatibility"><a class="header" href="#browser-compatibility">Browser Compatibility</a></h3>
<p>Perseus is compatible with any browser that supports Wasm, which is most modern browsers like Firefox and Chrome. However, legacy browsers like Internet Explorer will not work with any Perseus app, unless you <em>polyfill</em> support for WebAssembly.</p>
</details>
<p>By the way, remember this little bit of code in <code>src/lib.rs</code>?</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    static_aliases: {
        &quot;/test.txt&quot; =&gt; &quot;static/test.txt&quot;
    }
<span class="boring">}
</span></code></pre></pre>
<p>If you navigate to <a href="http://localhost:8080/test.txt">http://localhost:8080/test.txt</a>, you should see the contents on <code>static/test.txt</code>! You can also access them at <a href="http://localhost:8080/.perseus/static/test.txt">http://localhost:8080/.perseus/static/test.txt</a></p>
<h2 id="moving-forward-1"><a class="header" href="#moving-forward-1">Moving Forward</a></h2>
<p>Congratulations! You're now well on your way to building highly performant web apps in Rust! The remaining sections of this book are more reference-style, and won't guide you through building an app, but they'll focus instead on specific features of Perseus that can be used to make extremely powerful systems.</p>
<p>So go forth, and build!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define_app"><a class="header" href="#define_app"><code>define_app!</code></a></h1>
<p>The core of Perseus is how it interacts with the CLI, which acts as the engine that runs your code. The bridge between these two systems is the <code>define_app!</code> macro, which accepts a number of options that define your app.</p>
<p>The smallest this can reasonably get is a fully self-contained app (taken from <a href="https://github.com/arctic-hen7/perseus/tree/main/examples/tiny/src/lib.rs">here</a>):</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perseus::{define_app, ErrorPages, Template};
use std::rc::Rc;
use sycamore::template;
define_app! {
    templates: [
        Template::&lt;G&gt;::new(&quot;index&quot;).template(Rc::new(|_| {
            template! {
                p { &quot;Hello World!&quot; }
            }
        }))
    ],
    error_pages: ErrorPages::new(Rc::new(|url, status, err, _| {
        template! {
            p { (format!(&quot;An error with HTTP code {} occurred at '{}': '{}'.&quot;, status, url, err)) }
        }
    }))
}
<span class="boring">}
</span></code></pre></pre>
<p>In a more complex app though, this macro still remains very manageable (taken from <a href="https://github.com/arctic-hen7/perseus/tree/main/examples/showcase/src/lib.rs">here</a>):</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod error_pages;
mod templates;

use perseus::define_app;

define_app! {
    templates: [
        crate::templates::index::get_template::&lt;G&gt;(),
        crate::templates::about::get_template::&lt;G&gt;(),
        crate::templates::new_post::get_template::&lt;G&gt;(),
        crate::templates::post::get_template::&lt;G&gt;(),
        crate::templates::ip::get_template::&lt;G&gt;(),
        crate::templates::time_root::get_template::&lt;G&gt;(),
        crate::templates::time::get_template::&lt;G&gt;(),
        crate::templates::amalgamation::get_template::&lt;G&gt;()
    ],
    error_pages: crate::error_pages::get_error_pages(),
    locales: {
        default: &quot;en-US&quot;,
        other: [&quot;fr-FR&quot;, &quot;es-ES&quot;]
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<p>Here's a list of everything you can provide to the macro and what each one does (note that the order of these matters):</p>
<ul>
<li><code>root</code> (optional) -- the HTML <code>id</code> to which your app will be rendered, the default is <code>root</code>; this MUST be reflected in your <code>index.html</code> file as an exact replication (spacing and all) of <code>&lt;div id=&quot;root-id-here&quot;&gt;&lt;/div&gt;</code> (replacing <code>root-id-here</code> with the value of this property)</li>
<li><code>templates</code> -- defines a list of your templates in which order is irrelevant</li>
<li><code>error_pages</code> -- defines an instance of <code>ErrorPages</code>, which tells Perseus what to do on an error (like a <em>404 Not Found</em>)</li>
<li><code>locales</code> (optional) -- defines options for i18n (internationalization), this shouldn't be specified for apps not using i18n
<ul>
<li><code>default</code> -- the default locale of your app (e.g. <code>en-US</code>)</li>
<li><code>other</code> -- a list of the other locales your app supports</li>
</ul>
</li>
<li><code>static_aliases</code> (optional) -- a list of aliases to static files in your project (e.g. for a favicon)</li>
<li><code>config_manager</code> (optional) -- a custom configuration manager</li>
<li><code>translations_manager</code> (optional) -- a custom translations manager</li>
</ul>
<p><strong>WARNING:</strong> if you try to include something from outside the current directory in <code>static_aliases</code>, <strong>no part of your app will load</strong>! If you could include such content, you might end up serving <code>/etc/passwd</code>, which would be a major security risk.</p>
<h2 id="other-files"><a class="header" href="#other-files">Other Files</a></h2>
<p>There's only one other file that the <code>define_app!</code> macro expects to exist: <code>index.html</code>. Note that any content in the <code>&lt;head&gt;</code> of this will be on every page, above anything inserted by the template.</p>
<p>Here's an example of this file (taken from <a href="https://github.com/arctic-hen7/perseus/blob/main/examples/basic/index.html">here</a>):</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-views"><a class="header" href="#writing-views">Writing Views</a></h1>
<p>Perseus is fundamentally a high-level framework around <a href="https://github.com/sycamore-rs/sycamore">Sycamore</a>, which provides all the underlying reactivity and the ability to write code that turns into visible HTML elements.</p>
<p>It would be foolish to reproduce here all the fantastic work of Sycamore, and you can read <a href="https://sycamore-rs.netlify.app/docs/v0.6/getting_started/installation">their docs</a> to understand how reactivity, variable interpolation, and all the rest of their amazing systems work.</p>
<p>Note that Perseus makes some sections of Sycamore's docs irrelevant (namely the sections on routing and SSR), as they're managed internally. Note that if you want to use Perseus without the CLI (<em>very</em> brave), these sections will be extremely relevant:</p>
<h2 id="using-sycamore-without-perseus"><a class="header" href="#using-sycamore-without-perseus">Using Sycamore without Perseus</a></h2>
<p>If you want to create a pure SPA that can be rendered from static files without any server at all, you'll want to use Sycamore without Perseus. Note that this won't provide as good SEO (search engine optimization), and you'll miss out on a number of additional features (like i18n, inferred routing, and rendering strategies), but for applications where these are unnecessary, Sycamore is perfect on its own.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<p>If you're used to Rust, you might be expecting to be able to call <code>println!</code> or <code>dbg!</code> to easily print a value to the browser console while working on an app, however this is unfortunately not yet the case (this is an issue in the lower-level libraries that Perseus depends on).</p>
<p>However, Perseus exports a macro called <code>web_log!</code> that can be used to print to the console. It accepts syntax identical to <code>format!</code>, <code>println!</code>, and the like and behaves in the same way, but it will print to the browser console instead of the terminal.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="templates"><a class="header" href="#templates">Templates</a></h1>
<p>At the core of Perseus is its template system, which is how you'll define every page you'll ever build! However, it's important to understand a few of the nuances of this system so that you can build the best apps possible.</p>
<h2 id="templates-vs-pages"><a class="header" href="#templates-vs-pages">Templates vs Pages</a></h2>
<p>In Perseus, the idea of a <em>template</em> is very different to the idea of a <em>page</em>.</p>
<p>A <em>page</em> corresponds to a URL in your app, like the about page, the landing page, or an individual blog post.</p>
<p>A <em>template</em> can generate <em>many</em> pages or only one by using <em>rendering strategies</em>.</p>
<p>The best way to illustrate this is with the example of a simple blog, with each page stored in something like a CMS (content management system). This app would only need two templates (in addition to a landing page, an about page, etc.): <code>blog</code> and <code>post</code>. For simplicity, we'll put the list of all blog posts in <code>blog</code>, and then each post will have its own URL under <code>post</code>.</p>
<p>The <code>blog</code> template will be rendered to <code>/blog</code>, and will only use the <em>build state</em> strategy, fetching a list of all our posts from the CMS every time the blog is rebuilt (or you could use revalidation and incremental generation to mean you never have to rebuild at all, but that's beyond the scope of this section). This template only generates one page, providing it the properties of the list of blog posts. So, in this case, the <code>blog</code> template has generated the <code>/blog</code> page.</p>
<p>The <code>post</code> template is more complex, and it will generate <em>many</em> pages, one for each blog post. This would probably use the <em>build paths</em> strategy, which lets you fetch a list of blog posts from the CMS at build-time and invoke <em>build state</em> for each of them, which would then get their content, metadata, etc. Thus, the <code>post</code> template generates many pages.</p>
<p>Hopefully that explains the difference between a template and a post. This is a somewhat unintuitive part of Perseus, but it should be clear in the documentation what the difference is. Note however that old versions of the examples in the repository used these terms interchangeably, when they used to be the same. If you see any remaining ambiguity in the docs, please <a href="https://github.com/arctic-hen7/perseus/issues/new/choose">open an issue</a>!</p>
<h2 id="defining-a-template"><a class="header" href="#defining-a-template">Defining a Template</a></h2>
<p>You can define a template like so (taken from <a href="https://github.com/arctic-hen7/perseus/blob/main/examples/basic/src/templates/about.rs">the basic example</a>'s about page):</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perseus::{is_client, Template};
use std::rc::Rc;
use sycamore::prelude::{component, template, GenericNode, Template as SycamoreTemplate};

#[component(AboutPage&lt;G&gt;)]
pub fn about_page() -&gt; SycamoreTemplate&lt;G&gt; {
    template! {
        p { &quot;About.&quot; }
        p {
            (
                format!(
                    &quot;This is currently being run on the {}.&quot;,
                    if is_client!() {
                        &quot;client&quot;
                    } else {
                        &quot;server&quot;
                    }
                )
            )
        }
    }
}

pub fn get_template&lt;G: GenericNode&gt;() -&gt; Template&lt;G&gt; {
    Template::new(&quot;about&quot;)
        .template(template_fn())
        .head(head_fn())
}

pub fn template_fn&lt;G: GenericNode&gt;() -&gt; perseus::template::TemplateFn&lt;G&gt; {
    Rc::new(|_| {
        template! {
            AboutPage()
        }
    })
}

pub fn head_fn() -&gt; perseus::template::HeadFn {
    Rc::new(|_| {
        template! {
            title { &quot;About Page | Perseus Example ‚Äì Basic&quot; }
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>It's seen as convention in Perseus to define each template in its own file, which should expose a <code>get_template()</code> file. Note that this is just convention, and as long as you get an instance of <code>Template&lt;G&gt;</code> to the <code>define_app!</code> macro, it really doesn't matter. That said, using community conventions makes your code easier to understand and debug for others.</p>
<p>There's a list of all the methods available on a template <a href="https://docs.rs/perseus/0.2/perseus/template/struct.Template.html#implementations">here</a>, along with explanations of what they all do. Technically, you could just define a template without calling any of these, but that would just render a blank page, which would probably be useless.</p>
<h2 id="routing"><a class="header" href="#routing">Routing</a></h2>
<p>Perseus' routing system is basically invisible, there's no router that you need to work with, nor any place for you to define explicit routes. Instead, Perseus automatically infers the routes for all your templates and the pages they generate from their names!</p>
<p>The general rule is this: a template called <code>X</code> will be rendered at <code>/X</code>. Simple. What's more difficult to understand is what we call <em>template path domains</em>, which is the system that makes route inference possible. <strong>A template can only ever generate pages within the scope of its root path.</strong> Its root path is its name. In the example of a template called <code>X</code>, it can render <code>/X/Y</code>, <code>/X/Y/Z</code>, etc., but it can <em>never</em> render <code>/A</code>.</p>
<p>To generate paths within a template's domain, you can use the <em>build paths</em> and <em>incremental generation</em> strategies (more on those later). Both of these support dynamic parameters (which might be denoted in other languages as <code>/post/&lt;title&gt;/info</code> or the like).</p>
<h3 id="dynamic-parameters-above-the-domain"><a class="header" href="#dynamic-parameters-above-the-domain">Dynamic Parameters Above the Domain</a></h3>
<p>One niche case is defining a route like this: <code>/&lt;locale&gt;/about</code>. In this case, the <code>about</code> template is rendered underneath a dynamic parameter. This is currently impossible in Perseus, but the most common reason to need it, internationalization (making your app work in many language), is support out-of-the-box with Perseus.</p>
<h3 id="different-templates-in-the-same-domain"><a class="header" href="#different-templates-in-the-same-domain">Different Templates in the Same Domain</a></h3>
<p>It's perfectly possible in Perseus to define one template for <code>/post</code> (and its children) and a different one for <code>/post/new</code>. In fact, this is exactly what <a href="https://github.com/arctic-hen7/perseus/tree/main/examples/showcase">the showcase example</a> does, and you can check it out for inspiration. This is based on a simple idea: <strong>more specific templates win</strong> the routing contest.</p>
<p>There is one use-case though that requires a bit more fiddling: having a different template for the root path. A very common use-case for this would be having one template for <code>/posts</code>'s children (one URl for each blog post) and a different template for <code>/posts</code> itself that lists all available posts. Currently, the only way to do this is to define a property on the <code>posts</code> template that will be <code>true</code> if you're rendering for that root, and then to conditionally render the list of posts. Otherwise, you would render the given post content. This does require a lot of <code>Option&lt;T&gt;</code>s, but they could be safely unwrapped (data passing in Perseus is logical and safe).</p>
<h2 id="checking-render-context"><a class="header" href="#checking-render-context">Checking Render Context</a></h2>
<p>It's often necessary to make sure you're only running some logic on the client-side, particularly anything to do with <code>web_sys</code>, which will <code>panic!</code> if used on the server. Because Perseus renders your templates in both environments, you'll need to explicitly check if you want to do something only on the client (like get an authentication token from a cookie). This can be done trivially with the <code>is_client!</code> macro, which does exactly what it says on the tin. Here's an example from <a href="https://github.com/arctic-hen7/perseus/blob/main/examples/basic/src/templates/about.rs">here</a>:</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perseus::{is_client, Template};
use std::rc::Rc;
use sycamore::prelude::{component, template, GenericNode, Template as SycamoreTemplate};

#[component(AboutPage&lt;G&gt;)]
pub fn about_page() -&gt; SycamoreTemplate&lt;G&gt; {
    template! {
        p { &quot;About.&quot; }
        p {
            (
                format!(
                    &quot;This is currently being run on the {}.&quot;,
                    if is_client!() {
                        &quot;client&quot;
                    } else {
                        &quot;server&quot;
                    }
                )
            )
        }
    }
}

pub fn get_template&lt;G: GenericNode&gt;() -&gt; Template&lt;G&gt; {
    Template::new(&quot;about&quot;)
        .template(template_fn())
        .head(head_fn())
}

pub fn template_fn&lt;G: GenericNode&gt;() -&gt; perseus::template::TemplateFn&lt;G&gt; {
    Rc::new(|_| {
        template! {
            AboutPage()
        }
    })
}

pub fn head_fn() -&gt; perseus::template::HeadFn {
    Rc::new(|_| {
        template! {
            title { &quot;About Page | Perseus Example ‚Äì Basic&quot; }
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>This is a very contrived example, but what you should note if you try this is the flash from <code>server</code> to <code>client</code>, because the page is pre-rendered on the server and then hydrated on the client. This is an important principle of Perseus, and you should be aware of this potential flashing (easily solved by a less contrived example).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modifying-the-head"><a class="header" href="#modifying-the-head">Modifying the <code>&lt;head&gt;</code></a></h1>
<p>A big issue with only having one <code>index.html</code> file for your whole app is that you don't have the ability to define different <code>&lt;title&gt;</code>s and HTML metadata for each page.</p>
<p>However, Perseus overcomes this easily by allowing you to specify <code>.head()</code> on a <code>Template&lt;G&gt;</code>, which should return a closure that returns a <code>Template&lt;SsrNode&gt;</code> (but just write <code>perseus::template::HeadFn</code> as the return type, it's an alias for that). The <code>template!</code> you define here will be rendered to a <code>String</code> and directly interpolated into the <code>&lt;head&gt;</code> of any pages this template renders. If you need it to be different based on the properties, you're covered, it takes the same properties as the normal tempalte function!</p>
<p>The only particular thing to note here is that, because this is rendered to a <code>String</code>, this <strong>can't be reactive</strong>. Variable interpolation is fine, but after it's been rendered once, the <code>&lt;head&gt;</code> <strong>will not change</strong>. If you need to update it later, you should do that with <a href="https://docs.rs/web-sys"><code>web_sys</code></a>, which lets you directly access any DOM element with similar syntax to JavaScript (in fact, it's your one-stop shop for all things interfacing with the browser, as well as it's companion <a href="https://docs.rs/js-sys"><code>js-sys</code></a>).</p>
<p>Here's an example of modifying a page's metadata (taken from <a href="https://github.com/arctic-hen7/perseus/blob/main/examples/basic/src/templates/index.rs">here</a>):</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use perseus::{
</span><span class="boring">    http::header::{HeaderMap, HeaderName},
</span><span class="boring">    GenericNode, StringResultWithCause, Template,
</span><span class="boring">};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">use sycamore::prelude::{component, template, Template as SycamoreTemplate};
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Debug)]
</span><span class="boring">pub struct IndexPageProps {
</span><span class="boring">    pub greeting: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[component(IndexPage&lt;G&gt;)]
</span><span class="boring">pub fn index_page(props: IndexPageProps) -&gt; SycamoreTemplate&lt;G&gt; {
</span><span class="boring">    template! {
</span><span class="boring">        p {(props.greeting)}
</span><span class="boring">        a(href = &quot;/about&quot;, id = &quot;about-link&quot;) { &quot;About!&quot; }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn get_template&lt;G: GenericNode&gt;() -&gt; Template&lt;G&gt; {
</span><span class="boring">    Template::new(&quot;index&quot;)
</span><span class="boring">        .build_state_fn(Rc::new(get_build_props))
</span><span class="boring">        .template(template_fn())
</span><span class="boring">        .head(head_fn())
</span><span class="boring">        .set_headers_fn(set_headers_fn())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub async fn get_build_props(_path: String) -&gt; StringResultWithCause&lt;String&gt; {
</span><span class="boring">    Ok(serde_json::to_string(&amp;IndexPageProps {
</span><span class="boring">        greeting: &quot;Hello World!&quot;.to_string(),
</span><span class="boring">    })
</span><span class="boring">    .unwrap())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn template_fn&lt;G: GenericNode&gt;() -&gt; perseus::template::TemplateFn&lt;G&gt; {
</span><span class="boring">    Rc::new(|props: Option&lt;String&gt;| {
</span><span class="boring">        template! {
</span><span class="boring">            IndexPage(
</span><span class="boring">                serde_json::from_str::&lt;IndexPageProps&gt;(&amp;props.unwrap()).unwrap()
</span><span class="boring">            )
</span>        }
    })
}

pub fn head_fn() -&gt; perseus::template::HeadFn {
    Rc::new(|_| {
        template! {
<span class="boring">            title { &quot;Index Page | Perseus Example ‚Äì Basic&quot; }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn set_headers_fn() -&gt; perseus::template::SetHeadersFn {
</span><span class="boring">    Rc::new(|_| {
</span><span class="boring">        let mut map = HeaderMap::new();
</span><span class="boring">        map.insert(
</span><span class="boring">            HeaderName::from_lowercase(b&quot;x-test&quot;).unwrap(),
</span><span class="boring">            &quot;custom value&quot;.parse().unwrap(),
</span><span class="boring">        );
</span><span class="boring">        map
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modifying-http-headers"><a class="header" href="#modifying-http-headers">Modifying HTTP Headers</a></h1>
<p>Most of the time, you shouldn't need to touch the HTTP headers of your Perseus templates, but sometimes you will need to. A particular example of this is if you want your users' browsers to only cache a page for a certain amount of time (the default for Perseus if five minutes), then you'd need to set the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control"><code>Cache-Control</code></a> header.</p>
<p>Perseus supports inserting arbitrary HTTP headers for any response from the server that successfully returns a page generated from the template those headers are defined for. You can do this like so (taken from <a href="https://github.com/arctic-hen7/perseus/blob/main/examples/basic/src/templates/index.rs">here</a>):</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perseus::{
    http::header::{HeaderMap, HeaderName},
    GenericNode, StringResultWithCause, Template,
};
use serde::{Deserialize, Serialize};
use std::rc::Rc;
use sycamore::prelude::{component, template, Template as SycamoreTemplate};

#[derive(Serialize, Deserialize, Debug)]
pub struct IndexPageProps {
    pub greeting: String,
}

#[component(IndexPage&lt;G&gt;)]
pub fn index_page(props: IndexPageProps) -&gt; SycamoreTemplate&lt;G&gt; {
    template! {
        p {(props.greeting)}
        a(href = &quot;/about&quot;, id = &quot;about-link&quot;) { &quot;About!&quot; }
    }
}

pub fn get_template&lt;G: GenericNode&gt;() -&gt; Template&lt;G&gt; {
    Template::new(&quot;index&quot;)
        .build_state_fn(Rc::new(get_build_props))
        .template(template_fn())
        .head(head_fn())
        .set_headers_fn(set_headers_fn())
}

pub async fn get_build_props(_path: String) -&gt; StringResultWithCause&lt;String&gt; {
    Ok(serde_json::to_string(&amp;IndexPageProps {
        greeting: &quot;Hello World!&quot;.to_string(),
    })
    .unwrap())
}

pub fn template_fn&lt;G: GenericNode&gt;() -&gt; perseus::template::TemplateFn&lt;G&gt; {
    Rc::new(|props: Option&lt;String&gt;| {
        template! {
            IndexPage(
                serde_json::from_str::&lt;IndexPageProps&gt;(&amp;props.unwrap()).unwrap()
            )
        }
    })
}

pub fn head_fn() -&gt; perseus::template::HeadFn {
    Rc::new(|_| {
        template! {
            title { &quot;Index Page | Perseus Example ‚Äì Basic&quot; }
        }
    })
}

pub fn set_headers_fn() -&gt; perseus::template::SetHeadersFn {
    Rc::new(|_| {
        let mut map = HeaderMap::new();
        map.insert(
            HeaderName::from_lowercase(b&quot;x-test&quot;).unwrap(),
            &quot;custom value&quot;.parse().unwrap(),
        );
        map
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>Of note here is the <code>set_headers_fn</code> function, which returns a <code>HeaderMap</code>. This is then used on the template with <code>.set_headers_fn()</code>. Note that the function you provide will be given the state as an argument (ignored here), and you must return some headers (you can't return an error).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-pages"><a class="header" href="#error-pages">Error Pages</a></h1>
<p>When developing for the web, you'll need to be familiar with the idea of an <em>HTTP status code</em>, which is a numerical indication in HTTP (HyperText Transfer Protocol) of how the server reacted to a client's request. The most well-known of these is the infamous <em>404 Not Found</em> error, but there are dozens of these in total. Don't worry, you certainly don't need to know all of them by heart!</p>
<h2 id="handling-http-status-codes-in-perseus"><a class="header" href="#handling-http-status-codes-in-perseus">Handling HTTP Status Codes in Perseus</a></h2>
<p>Perseus has an <em>app shell</em> that manages fetching pages for the user (it's a little more complicated than the traditional design of that kind of a system, but that's all you need to know for now), and this is where HTTP errors will occur as it communicates with the Perseus server. If the status code is an error, this shell will fail and render an error page instead of the page the user visited. This way, an error page can be displayed at any route, without having to navigate to a special route.</p>
<p>You can define one error page for each HTTP status code in Perseus, and you can see a list of those <a href="https://httpstatuses.com">here</a>. Here's an example of doing so for <em>404 Not Found</em> and <em>400</em> (a generic error caused by the client) (taken from <a href="https://github.com/arctic-hen7/perseus/tree/main/examples/showcase/src/error_pages.rs">here</a>):</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perseus::{ErrorPages, GenericNode};
use std::rc::Rc;
use sycamore::template;

pub fn get_error_pages&lt;G: GenericNode&gt;() -&gt; ErrorPages&lt;G&gt; {
    let mut error_pages = ErrorPages::new(Rc::new(|_, _, _, _| {
        template! {
            p { &quot;Another error occurred.&quot; }
        }
    }));
    error_pages.add_page(
        404,
        Rc::new(|_, _, _, _| {
            template! {
                p { &quot;Page not found.&quot; }
            }
        }),
    );
    error_pages.add_page(
        400,
        Rc::new(|_, _, _, _| {
            template! {
                p { &quot;Client error occurred...&quot; }
            }
        }),
    );

    error_pages
}
<span class="boring">}
</span></code></pre></pre>
<p>It's conventional in Perseus to define a file called <code>src/error_pages.rs</code> and put your error pages in here for small apps, but for larger apps where your error pages are customized with beautiful logos and animations, you'll almost certainly want this to be a folder, and to have a separate file for each error page.</p>
<p>When defining an instance of <code>ErrorPages</code>, you'll need to provide a fallback page, which will be used for all the status codes that you haven't specified unique pages for. In the above example, this fallback would be used for, say, a <em>500</em> error, which indicates an internal server error.</p>
<p>The most important thing to note about these error pages is the arguments they each take, which have all been ignored in the above example with <code>_</code>s. There are four of these:</p>
<ul>
<li>URL that caused the error</li>
<li>HTTP status code (<code>u16</code>)</li>
<li>Error message</li>
<li>Translator (inside an <code>Option&lt;T&gt;</code>)</li>
</ul>
<h2 id="translations-in-error-pages"><a class="header" href="#translations-in-error-pages">Translations in Error Pages</a></h2>
<p>Error pages are also available for you to use yourself (see the <a href="https://docs.rs/perseus">API docs</a> on the functions to call for that) if an error occurs in one of your own pages, and in that case, if you're using i18n, you'll have a <code>Translator</code> available. However, there are <em>many</em> cases in Perseus in which translators are not available to error pages (e.g. the error page might have been rendered because the translator couldn't be initialized for some reason), and in these cases, while it may be tempting to fall back to the default locale, you should optimally make your page as easy to decipher for speakers of other languages as possible. This means emoji, pictures, icons, etc. Bottom line: if the fourth parameter to an error page is <code>None</code>, then communicate as universally as possible.</p>
<p>An alternative is just to display an error message in every language that your app supports, which may in some cases be easier and more practical.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="static-content"><a class="header" href="#static-content">Static Content</a></h1>
<p>It's very routine in a web app to need to access <em>static content</em>, like images, and Perseus supports this out-of-the-box. Any and all static content for your website that should be served over the network should be put in a directory called <code>static/</code>, which should be at the root of your project (NOT under <code>src/</code>!). Any files/folders you put in there will be accessible on your website at <code>/.perseus/static/[filename-here]</code> <strong>to anyone</strong>. If you need content to be protected in some way, this is not the mechanism to use (consider a separate API endpoint)!</p>
<h2 id="aliasing-static-content"><a class="header" href="#aliasing-static-content">Aliasing Static Content</a></h2>
<p>One problem with making all static content available under <code>/.perseus/static/</code>  is that there are sometimes occasions where you need it available at other locations. The most common example of this is <code>/favicon.ico</code> (the little logo that appears next to your app's title in a browser tab), which must be at that path.</p>
<p><em>Static aliases</em> allow you to handle these conditions with ease, as they let you define static content to be available at any given path, and to map to any given file in your project's directory.</p>
<p>You can define static aliases in the <code>define_app!</code> macro's <code>static_aliases</code> parameter. Here's an example from <a href="https://github.com/arctic-hen7/perseus/blob/main/examples/basic/src/lib.rs">here</a>:</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod error_pages;
mod templates;

use perseus::define_app;

define_app! {
    templates: [
        crate::templates::index::get_template::&lt;G&gt;(),
        crate::templates::about::get_template::&lt;G&gt;()
    ],
    error_pages: crate::error_pages::get_error_pages(),
    static_aliases: {
        &quot;/test.txt&quot; =&gt; &quot;static/test.txt&quot;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="security"><a class="header" href="#security">Security</a></h3>
<p>Of course, being able to serve any file on your system in a public-facing app is a major security vulnerability, so Perseus will only allow you to create aliases for paths in the current directory. Any absolute paths or paths that go outside the current directory will be disallowed. Note that these paths are defined relative to the root of your project.</p>
<p><strong>WARNING:</strong> if you accidentally violate this requirement, your app <strong>will not load</strong> at all!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="internationalization"><a class="header" href="#internationalization">Internationalization</a></h1>
<p>Internationalization (abbreviated <em>i18n</em>) is making an app available in many languages. Perseus supports this out-of-the-box with <a href="https://projectfluent.org">Fluent</a>.</p>
<p>The approach usually taken to i18n is to use translation IDs in your code instead of natural language. For example, instead of writing <code>format!(&quot;Hello, {}!&quot;, name.get())</code>, you'd write something like <code>t!(&quot;greeting&quot;, {&quot;name&quot; =&gt; name.get()})</code>. This ensures that your app works well for people across the world, and is crucial for any large apps.</p>
<p>This section will explain how i18n works in Perseus and how to use it to make lightning-fast apps that work for people across the planet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-translations"><a class="header" href="#defining-translations">Defining Translations</a></h1>
<p>The first part of setting up i18n in Perseus is to state that your app uses it, which is done in the <code>define-app!</code> macro like so (taken from <a href="https://github.com/arctic-hen7/perseus/tree/main/examples/i18n">the i18n example</a>):</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod error_pages;
mod templates;

use perseus::define_app;

define_app! {
    templates: [
        crate::templates::about::get_template::&lt;G&gt;(),
        crate::templates::index::get_template::&lt;G&gt;(),
        crate::templates::post::get_template::&lt;G&gt;()
    ],
    error_pages: crate::error_pages::get_error_pages(),
    locales: {
        default: &quot;en-US&quot;,
        other: [&quot;fr-FR&quot;, &quot;es-ES&quot;]
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>There are two subfields under the <code>locales</code> key: <code>default</code> and <code>other</code>. Each of these locales should be specified in the form <code>xx-XX</code>, where <code>xx</code> is the language code (e.g. <code>en</code> for English, <code>fr</code> for French, <code>la</code> for Latin) and <code>XX</code> is the region code (e.g. <code>US</code> for United States, <code>GB</code> for Great Britain, <code>CN</code> for China).</p>
<h2 id="routing-1"><a class="header" href="#routing-1">Routing</a></h2>
<p>After you've enabled i18n like so, every page on your app will be rendered behind a locale. For example, <code>/about</code> will become <code>/en-US/about</code>, <code>/fr-FR/about</code>, and<code>/es-ES/about</code> in the above example. These are automatically rendered by Perseus at build-time, and they behave exactly the same as every other feature of Perseus.</p>
<p>Of course, it's hardly optimal to direct users to a pre-translated page if they may prefer it in another language, which is why Perseus supports <em>locale detection</em> automatically. In other words, you can direct users to <code>/about</code>, and they'll automatically be redirected to <code>/&lt;locale&gt;/about</code>, where <code>&lt;locale&gt;</code> is their preferred locale according to <code>navigator.languages</code>. This matching is done based on <a href="https://www.rfc-editor.org/rfc/rfc4647.txt">RFC 4647</a>, which defines how locale detection should be done.</p>
<h2 id="adding-translations"><a class="header" href="#adding-translations">Adding Translations</a></h2>
<p>After you've added those definitions to <code>define_app!</code>, if you try to run your app, you'll find that ever page throws an error because it can't find any of the translations files. These must be defined under <code>translations/</code> (which should be NEXT to <code>/src</code>, not under it!), though this can be customized (explained later). They must also adhere to the naming format <code>xx-XX.ftl</code> (e.g. <code>en-US.ftl</code>). <code>.ftl</code> is the file extension that <a href="https://projectfluent.org">Fluent</a> files use, which is the default translations system of Perseus. If you'd like to use a different system, this will be explained later.</p>
<p>Here's an example of a translations file (taken from <a href="https://github.com/arctic-hen7/perseus/blob/main/examples/i18n/translations/en-US.ftl">here</a>):</p>
<pre><code class="language-fluent">hello = Hello, { $user }!
about = Welcome to the about page (English)!
</code></pre>
<p>You can read more about Fluent's syntax <a href="https://projectfluent.org">here</a> (it's <em>very</em> powerful).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-translations"><a class="header" href="#using-translations">Using Translations</a></h1>
<p>Perseus tries to make it as easy as possible to use translations in your app by exposing the low-level Fluent primitives necessary to work with very complex translations, as well as a <code>t!</code> macro that does the basics.</p>
<p>All translations in Perseus are done with an instance of <code>Translator</code>, which is provided through Sycamore's <a href="https://sycamore-rs.netlify.app/docs/v0.6/advanced/contexts">context system</a>. Here's an example taken from <a href="https://github.com/arctic-hen7/perseus/blob/main/examples/i18n/src/templates/index.rs">here</a>:</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perseus::{link, t, Template, Translator};
use std::rc::Rc;
use sycamore::prelude::{component, template, GenericNode, Template as SycamoreTemplate};

#[component(IndexPage&lt;G&gt;)]
pub fn index_page() -&gt; SycamoreTemplate&lt;G&gt; {
    let username = &quot;User&quot;;
    template! {
        p { (t!(&quot;hello&quot;, {
            &quot;user&quot;: username
        })) }
        a(href = link!(&quot;/about&quot;)) { &quot;About&quot; }
    }
}

pub fn template_fn&lt;G: GenericNode&gt;() -&gt; perseus::template::TemplateFn&lt;G&gt; {
    Rc::new(|_| {
        template! {
            IndexPage()
        }
    })
}

pub fn get_template&lt;G: GenericNode&gt;() -&gt; Template&lt;G&gt; {
    Template::new(&quot;index&quot;).template(template_fn())
}
<span class="boring">}
</span></code></pre></pre>
<p>In that example, we've imported <code>perseus::t</code>, and we use it to translate the <code>hello</code> ID, which takes an argument for the username. Notice that we don't provide a locale, Perseus handles all this in the background for us. </p>
<h2 id="getting-the-translator"><a class="header" href="#getting-the-translator">Getting the <code>Translator</code></a></h2>
<p>That said, there are some cases in which you'll want access to the underlying <code>Translator</code> so you can do more complex things. You can get it like so:</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>sycamore::context::use_context::&lt;Rc&lt;Translator&gt;&gt;();
<span class="boring">}
</span></code></pre></pre>
<p>To see all the methods available on <code>Translator</code>, see <a href="https://docs.rs/perseus">the API docs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="translations-managers"><a class="header" href="#translations-managers">Translations Managers</a></h1>
<p>As mentioned earlier, Perseus expects your translations to be in the very specific location of <code>translations/&lt;locale&gt;.ftl</code>, which may not be feasible or preferable in all cases. In fact, there may indeed be cases where translations might be stored in an external database (not recommended for performance as translations are regularly requested, filesystem storage with caching is far faster).</p>
<p>If you'd like to change this default behavior, this section is for you! Perseus manages the locations of translations with a <code>TranslationsManager</code>, which defines a number of methods for accessing translations, and should implement caching internally. Perseus has two inbuilt managers: <code>FsTranslationsManager</code> and <code>DummyTranslationsManager</code>. The former is used by default, and the latter if i18n is disabled.</p>
<h2 id="using-a-custom-translations-manager"><a class="header" href="#using-a-custom-translations-manager">Using a Custom Translations Manager</a></h2>
<p>The <code>define_app!</code> macro accepts a property called <code>translations_manager</code> if you define <code>locales</code>, which can be used to specify a non-default translations manager.</p>
<h2 id="using-a-custom-directory"><a class="header" href="#using-a-custom-directory">Using a Custom Directory</a></h2>
<p>If you just want to change the directory in which translations are stored, you can still use <code>FsTranslationsmanager</code>, just initialize it with a different directory, and make sure to set up caching properly. See <a href="https://github.com/arctic-hen7/perseus/blob/f7f7892fbf124a7d887b1f22a1641c79773d6246/packages/perseus/src/macros.rs#L35-L50">here</a> for how this is done internally.</p>
<h2 id="building-a-custom-translations-manager"><a class="header" href="#building-a-custom-translations-manager">Building a Custom Translations Manager</a></h2>
<p>This is more complex, and you'll need to consult <a href="https://github.com/arctic-hen7/perseus/blob/main/packages/perseus/src/translations_manager.rs">this file</a> (note: the client translations manager is very different) in the Perseus source code for guidance. If you're stuck, don't hesitate to ask a question under <a href="https://github.com/arctic-hen7/perseus/discussions/new">discussions</a> on GitHub!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other-translation-engines"><a class="header" href="#other-translation-engines">Other Translation Engines</a></h1>
<p>Perseus uses <a href="https://projectfluent.org">Fluent</a> for i18n by default, but this isn't set in stone. Rather than providing only one instance of <code>Translator</code>, Perseus can support many through Cargo's features system. By default, Perseus will enable the <code>translator-fluent</code> feature to build a <code>Translator</code> <code>struct</code> that uses Fluent. The <code>translator-dflt-fluent</code> feature will also be enabled, which sets <code>perseus::Translator</code> to be an alias for <code>FluentTranslator</code>.</p>
<p>If you want to create a translator for a different system, this will need to be integrated into Perseus as a pull request, but we're more than happy to help with these efforts. Optimally, Perseus will in future support multiple translations systems, and developers will be able to pick the one they like the most</p>
<h2 id="why-not-a-trait"><a class="header" href="#why-not-a-trait">Why Not a Trait?</a></h2>
<p>It may seem like this problem could simply be solved with a <code>Translator</code> trait, as is done with translations managers, but unfortunately this isn't so simple because of the way translators are transported through the app. The feature-gating solution was chosen as the best compromise between convenience and performance.</p>
<h2 id="how-do-i-make-one"><a class="header" href="#how-do-i-make-one">How Do I Make One?</a></h2>
<p>If you want to make your own alternative translation engine, please <a href="https://github.com/arctic-hen7/perseus/issues/new/choose">open an issue</a> about it, explaining the system you want to support. Provided the system is compatible with Perseus' i18n design (which it certainly should be if we've done our job correctly!), we'll be happy to help you get it into Perseus!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rendering-strategies"><a class="header" href="#rendering-strategies">Rendering Strategies</a></h1>
<p>This section describes Perseus' rendering strategies, which differentiate it from every other framework in the world right now. Note that all the strategies detailed here can be used together, and the <a href="https://github.com/arctic-hen7/perseus/tree/main/examples/showcase">showcase example</a> is the best example of seeing how each one can be used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-state"><a class="header" href="#build-state">Build State</a></h1>
<p>The most commonly-used rendering strategy for Perseus is static generation, which renders your pages to static HTML files. These can then be served by the server with almost no additional processing, which makes for an extremely fast experience!</p>
<p>Note that, depending on other strategies used, Perseus may call this strategy at build-time or while the server is running, so you shouldn't depend on anything only present in a build environment (particularly if you're using the <em>incremental generation</em> or <em>revalidation</em> strategies).</p>
<p><em>Note: Perseus currently still requires a server if you want to export to purely static files, though standalone exports may be added in a future release. In the meantime, check out <a href="https://getzola.org">Zola</a>, which does pure static generation fantastically.</em></p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<h3 id="without-build-paths-or-incremental-generation"><a class="header" href="#without-build-paths-or-incremental-generation">Without <em>Build Paths</em> or <em>Incremental Generation</em></a></h3>
<p>On its own, this strategy will simply generate properties for your template to turn it into a page, which would be perfect for something like a list of blog posts (just fetch the list from the filesystem, a database, etc.). Here's an example from <a href="https://github.com/arctic-hen7/perseus/blob/main/examples/showcase/src/templates/index.rs">here</a> for a simple greeting:</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perseus::{StringResultWithCause, Template};
use serde::{Deserialize, Serialize};
use std::rc::Rc;
use sycamore::prelude::{component, template, GenericNode, Template as SycamoreTemplate};

#[derive(Serialize, Deserialize, Debug)]
pub struct IndexPageProps {
    pub greeting: String,
}

#[component(IndexPage&lt;G&gt;)]
pub fn index_page(props: IndexPageProps) -&gt; SycamoreTemplate&lt;G&gt; {
    template! {
        p {(props.greeting)}
    }
}

pub fn get_template&lt;G: GenericNode&gt;() -&gt; Template&lt;G&gt; {
    Template::new(&quot;index&quot;)
        .build_state_fn(Rc::new(get_static_props))
        .template(template_fn())
}

pub async fn get_static_props(_path: String) -&gt; StringResultWithCause&lt;String&gt; {
    Ok(serde_json::to_string(&amp;IndexPageProps {
        greeting: &quot;Hello World!&quot;.to_string(),
    })
    .unwrap())
}

pub fn template_fn&lt;G: GenericNode&gt;() -&gt; perseus::template::TemplateFn&lt;G&gt; {
    Rc::new(|props| {
        template! {
            IndexPage(
                serde_json::from_str::&lt;IndexPageProps&gt;(&amp;props.unwrap()).unwrap()
            )
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that Perseus passes around properties to pages as <code>String</code>s, so the function used for this strategy is expected to return a string. Note also the return type <code>StringResultWithCause</code>, which means you can specify an error as <code>(String, perseus::errors::ErrorCause)</code>, the later part of which can either be <code>Client(Option&lt;u16&gt;)</code> or <code>Server(Option&lt;u16&gt;)</code>. The <code>u16</code>s allow specifying a custom HTTP status code, otherwise the defaults are <em>400</em> and <em>500</em> respectively. This return type allows specifying who's responsible for an error. This is irrelevant if you use this strategy on its own or with <em>build paths</em>, but if you bring in <em>incremental generation</em>, this will be necessary.</p>
<h3 id="with-build-paths-or-incremental-generation"><a class="header" href="#with-build-paths-or-incremental-generation">With <em>Build Paths</em> or <em>Incremental Generation</em></a></h3>
<p>You may have noticed in the above example that the build state function takes a <code>path</code> parameter. This becomes useful once you bring the <em>build paths</em> or <em>incremental generation</em> strategies into play, which allow you to render many paths for a single template. In the following example (taken from <a href="https://github.com/arctic-hen7/perseus/blob/main/examples/showcase/src/templates/post.rs">here</a>), all three strategies are used together to pre-render some blog posts at build-time, and allow the rest to be requested and rendered if they exist (here, any post will exist except one called <code>tests</code>):</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perseus::{ErrorCause, StringResultWithCause, Template};
use serde::{Deserialize, Serialize};
use std::rc::Rc;
use sycamore::prelude::{component, template, GenericNode, Template as SycamoreTemplate};

#[derive(Serialize, Deserialize)]
pub struct PostPageProps {
    title: String,
    content: String,
}

#[component(PostPage&lt;G&gt;)]
pub fn post_page(props: PostPageProps) -&gt; SycamoreTemplate&lt;G&gt; {
    let title = props.title;
    let content = props.content;
    template! {
        h1 {
            (title)
        }
        p {
            (content)
        }
    }
}

pub fn get_template&lt;G: GenericNode&gt;() -&gt; Template&lt;G&gt; {
    Template::new(&quot;post&quot;)
        .build_paths_fn(Rc::new(get_static_paths))
        .build_state_fn(Rc::new(get_static_props))
        .incremental_generation()
        .template(template_fn())
}

pub async fn get_static_props(path: String) -&gt; StringResultWithCause&lt;String&gt; {
    // This path is illegal, and can't be rendered
    if path == &quot;post/tests&quot; {
        return Err((&quot;illegal page&quot;.to_string(), ErrorCause::Client(Some(404))));
    }
    // This is just an example
    let title = urlencoding::decode(&amp;path).unwrap();
    let content = format!(
        &quot;This is a post entitled '{}'. Its original slug was '{}'.&quot;,
        title, path
    );

    Ok(serde_json::to_string(&amp;PostPageProps {
        title: title.to_string(),
        content,
    })
    .unwrap())
}

pub async fn get_static_paths() -&gt; Result&lt;Vec&lt;String&gt;, String&gt; {
    Ok(vec![&quot;test&quot;.to_string(), &quot;blah/test/blah&quot;.to_string()])
}

pub fn template_fn&lt;G: GenericNode&gt;() -&gt; perseus::template::TemplateFn&lt;G&gt; {
    Rc::new(|props| {
        template! {
            PostPage(
                serde_json::from_str::&lt;PostPageProps&gt;(&amp;props.unwrap()).unwrap()
            )
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>When either of these additional strategies are used, <em>build state</em> will be passed the path of the page to be rendered, which allows it to prepare unique properties for that page. In the above example, it just turns the URL into a title and renders that.</p>
<p>For further details on <em>build paths</em> and <em>incremental generation</em>, see the following sections.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-paths"><a class="header" href="#build-paths">Build Paths</a></h1>
<p>As touched on in the documentation on the <em>build state</em> strategy, Perseus can easily turn one template into many pages (e.g. one blog post template into many blog post pages) with the <em>build paths</em> strategy, which is a function that returns a <code>Vec&lt;String&gt;</code> of paths to build.</p>
<p>Note that it's often unwise to use this strategy to render all your blog posts or the like, but only render the top give most commonly accessed or the like, if any at all. This is relevant mostly when you have a large number of pages to be generated. The <em>incremental generation</em> strategy is better suited for this, and it also allows you to never need to rebuild your site for new content (as long as the server can access the new content).</p>
<p>Note that, like <em>build state</em>, this strategy may be invoked at build-time or while the server is running if you use the <em>revalidation</em> strategy (<em>incremental generation</em> doesn't affect <em>build paths</em> though).</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<p>Here's the same example as given in the previous section (taken from <a href="https://github.com/arctic-hen7/perseus/blob/main/examples/showcase/src/templates/post.rs">here</a>), which uses <em>build paths</em> together with <em>build state</em> and <em>incremental generation</em>:</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perseus::{ErrorCause, StringResultWithCause, Template};
use serde::{Deserialize, Serialize};
use std::rc::Rc;
use sycamore::prelude::{component, template, GenericNode, Template as SycamoreTemplate};

#[derive(Serialize, Deserialize)]
pub struct PostPageProps {
    title: String,
    content: String,
}

#[component(PostPage&lt;G&gt;)]
pub fn post_page(props: PostPageProps) -&gt; SycamoreTemplate&lt;G&gt; {
    let title = props.title;
    let content = props.content;
    template! {
        h1 {
            (title)
        }
        p {
            (content)
        }
    }
}

pub fn get_template&lt;G: GenericNode&gt;() -&gt; Template&lt;G&gt; {
    Template::new(&quot;post&quot;)
        .build_paths_fn(Rc::new(get_static_paths))
        .build_state_fn(Rc::new(get_static_props))
        .incremental_generation()
        .template(template_fn())
}

pub async fn get_static_props(path: String) -&gt; StringResultWithCause&lt;String&gt; {
    // This path is illegal, and can't be rendered
    if path == &quot;post/tests&quot; {
        return Err((&quot;illegal page&quot;.to_string(), ErrorCause::Client(Some(404))));
    }
    // This is just an example
    let title = urlencoding::decode(&amp;path).unwrap();
    let content = format!(
        &quot;This is a post entitled '{}'. Its original slug was '{}'.&quot;,
        title, path
    );

    Ok(serde_json::to_string(&amp;PostPageProps {
        title: title.to_string(),
        content,
    })
    .unwrap())
}

pub async fn get_static_paths() -&gt; Result&lt;Vec&lt;String&gt;, String&gt; {
    Ok(vec![&quot;test&quot;.to_string(), &quot;blah/test/blah&quot;.to_string()])
}

pub fn template_fn&lt;G: GenericNode&gt;() -&gt; perseus::template::TemplateFn&lt;G&gt; {
    Rc::new(|props| {
        template! {
            PostPage(
                serde_json::from_str::&lt;PostPageProps&gt;(&amp;props.unwrap()).unwrap()
            )
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>Note the return type of the <code>get_build_paths</code> function, which returns a vector of <code>String</code>s on success or a <code>String</code> error.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="request-state"><a class="header" href="#request-state">Request State</a></h1>
<p>While build-time strategies fulfill many use-cases, there are also scenarios in which you may need access to information only available at request-time, like an authentication key that the client sends over HTTP as a cookie. For these cases, Perseus supports the <em>request state</em> strategy, which is akin to traditional server-side rendering, whereby you render the page when a client requests it.</p>
<p>If you can avoid this strategy, do, because it will bring your app's TTFB (time to first byte) down, remember that anything done in this strategy is done on the server while the client is waiting for a page.</p>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<p>Here's an example taken from <a href="https://github.com/arctic-hen7/perseus/blob/main/examples/showcase/src/templates/ip.rs">here</a> of using this strategy to tell the user their own IP address (albeit not hugely reliably as this header can be trivially spoofed, but this is for demonstration purposes):</p>
<pre><pre class="playground"><code class="language-rust no-run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perseus::{Request, StringResultWithCause, Template};
use serde::{Deserialize, Serialize};
use std::rc::Rc;
use sycamore::prelude::{component, template, GenericNode, Template as SycamoreTemplate};

#[derive(Serialize, Deserialize)]
pub struct IpPageProps {
    ip: String,
}

#[component(IpPage&lt;G&gt;)]
pub fn dashboard_page(props: IpPageProps) -&gt; SycamoreTemplate&lt;G&gt; {
    template! {
        p {
            (
                format!(&quot;Your IP address is {}.&quot;, props.ip)
            )
        }
    }
}

pub fn get_template&lt;G: GenericNode&gt;() -&gt; Template&lt;G&gt; {
    Template::new(&quot;ip&quot;)
        .request_state_fn(Rc::new(get_request_state))
        .template(template_fn())
}

pub async fn get_request_state(_path: String, req: Request) -&gt; StringResultWithCause&lt;String&gt; {
    // Err((&quot;this is a test error!&quot;.to_string(), perseus::ErrorCause::Client(None)))
    Ok(serde_json::to_string(&amp;IpPageProps {
        // Gets the client's IP address
        ip: format!(
            &quot;{:?}&quot;,
            req.headers()
                .get(&quot;X-Forwarded-For&quot;)
                .unwrap_or(&amp;perseus::http::HeaderValue::from_str(&quot;hidden from view!&quot;).unwrap())
        ),
    })
    .unwrap())
}

pub fn template_fn&lt;G: GenericNode&gt;() -&gt; perseus::template::TemplateFn&lt;G&gt; {
    Rc::new(|props| {
        template! {
            IpPage(
                serde_json::from_str::&lt;IpPageProps&gt;(&amp;props.unwrap()).unwrap()
            )
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that, just like <em>build state</em>, this strategy generates stringified properties that will be passed to the page to render it, and it also uses <code>StringResultWithCause</code> (see the section on <a href="strategies/./build-state.html">build state</a> for more information). The key difference though is that this strategy receives a second, very powerful parameter: the HTTP request that the user sent (<code>perseus::Request</code>).</p>
<details>
<summary>How do you get the user's request information?</summary>
<p><a href="https://actix.rs">Actix Web</a> (and any other framework worth its salt) automatically passes this information to handlers like Perseus. The slightly difficult thing is then converting this from Actix's custom format to Perseus' (which is just an alias for the <a href="https://docs.rs/http"><code>http</code></a> module's). This is done in the <a href="https://docs.rs/perseus-actix-web"><code>perseus-actix-web</code></a> crate.</p>
</details>
<p>That parameter is actually just an alias for <a href="https://docs.rs/http/0.2/http/request/struct.Request.html">this</a>, which gives you access to all manner of things in the user's HTTP request. The main one we're concerned with in this example though is <code>X-Forwarded-For</code>, which contains the user's IP address (unless it's trivially spoofed). Because we can't assume that any HTTP header exists, we fall back to a message saying the IP address is hidden if we can't access the header.</p>
<p>The other notable thing in the above example is the commented-out line at the beginning of <code>get_request_state</code>, which shows you how to return an error if the client didn't provide something that they should've.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="revalidation"><a class="header" href="#revalidation">Revalidation</a></h1>
<p>While the <em>build state</em> and <em>build paths</em> strategies are excellent for generating pages efficiently, they can't be updated for new content. For example, using these strategies alone, you'd need to rebuild a blog every time you added a new post, even if those posts were stored in a database. With <em>revalidation</em>, you can avoid this by instructing Perseus to rebuild a template if certain criteria are met when it's requested.</p>
<p>There are two types of revalidation: time-based and logic-based. The former lets you re-render a template every 24 hours or the like, while the latter allows you to re-render a template if an arbitrary function returns <code>true</code>.</p>
<h2 id="time-based-revalidation-usage"><a class="header" href="#time-based-revalidation-usage">Time-Based Revalidation Usage</a></h2>
<p>Here's an example of time-based revalidation from <a href="https://github.com/arctic-hen7/perseus/blob/main/examples/showcase/src/templates/time.rs">here</a> (note that this uses <em>incremental generation</em> as well):</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perseus::{ErrorCause, StringResultWithCause, Template};
use serde::{Deserialize, Serialize};
use std::rc::Rc;
use sycamore::prelude::{component, template, GenericNode, Template as SycamoreTemplate};

#[derive(Serialize, Deserialize, Debug)]
pub struct TimePageProps {
    pub time: String,
}

#[component(TimePage&lt;G&gt;)]
pub fn time_page(props: TimePageProps) -&gt; SycamoreTemplate&lt;G&gt; {
    template! {
        p { (format!(&quot;The time when this page was last rendered was '{}'.&quot;, props.time)) }
    }
}

pub fn get_template&lt;G: GenericNode&gt;() -&gt; Template&lt;G&gt; {
    Template::new(&quot;timeisr&quot;)
        .template(template_fn())
        // This page will revalidate every five seconds (to illustrate revalidation)
        .revalidate_after(&quot;5s&quot;.to_string())
        .incremental_generation()
        .build_state_fn(Rc::new(get_build_state))
        .build_paths_fn(Rc::new(get_build_paths))
}

pub async fn get_build_state(path: String) -&gt; StringResultWithCause&lt;String&gt; {
    // This path is illegal, and can't be rendered
    if path == &quot;timeisr/tests&quot; {
        return Err((&quot;illegal page&quot;.to_string(), ErrorCause::Client(Some(404))));
    }
    Ok(serde_json::to_string(&amp;TimePageProps {
        time: format!(&quot;{:?}&quot;, std::time::SystemTime::now()),
    })
    .unwrap())
}

pub async fn get_build_paths() -&gt; Result&lt;Vec&lt;String&gt;, String&gt; {
    Ok(vec![&quot;test&quot;.to_string()])
}

pub fn template_fn&lt;G: GenericNode&gt;() -&gt; perseus::template::TemplateFn&lt;G&gt; {
    Rc::new(|props| {
        template! {
            TimePage(
                serde_json::from_str::&lt;TimePageProps&gt;(&amp;props.unwrap()).unwrap()
            )
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>This page displays the time at which it was built (fetched with <em>build state</em>), but rebuilds every five seconds. Note that this doesn't translate to the server's actually rebuilding it every five seconds, but rather the server will rebuild it at the next request if more than five seconds have passed since it was last built (meaning templates on the same build schedule will likely go our of sync quickly).</p>
<h3 id="time-syntax"><a class="header" href="#time-syntax">Time Syntax</a></h3>
<p>Perseus uses a very simple syntax inspired by <a href="strategies/">this JavaScript project</a> to specify time intervals in the form <code>xXyYzZ</code> (e.g. <code>1w</code>, <code>5s</code>, <code>1w5s</code>), where the lower-case letters are number and the upper-case letters are intervals, the supported of which are listed below:</p>
<ul>
<li><code>s</code>: second,</li>
<li><code>m</code>: minute,</li>
<li><code>h</code>: hour,</li>
<li><code>d</code>: day,</li>
<li><code>w</code>: week,</li>
<li><code>M</code>: month (30 days used here, 12M ‚â† 1y!),</li>
<li><code>y</code>: year (365 days always, leap years ignored, if you want them add them as days)</li>
</ul>
<h2 id="logic-based-revalidation-usage"><a class="header" href="#logic-based-revalidation-usage">Logic-Based Revalidation Usage</a></h2>
<p>Here's an example of logic-based revalidation from <a href="https://github.com/arctic-hen7/perseus/blob/main/examples/showcase/src/templates/time_root.rs">here</a> (actually, this example uses both types of revalidation):</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perseus::{StringResultWithCause, Template};
use serde::{Deserialize, Serialize};
use std::rc::Rc;
use sycamore::prelude::{component, template, GenericNode, Template as SycamoreTemplate};

#[derive(Serialize, Deserialize, Debug)]
pub struct TimePageProps {
    pub time: String,
}

#[component(TimePage&lt;G&gt;)]
pub fn time_page(props: TimePageProps) -&gt; SycamoreTemplate&lt;G&gt; {
    template! {
        p { (format!(&quot;The time when this page was last rendered was '{}'.&quot;, props.time)) }
    }
}

pub fn get_template&lt;G: GenericNode&gt;() -&gt; Template&lt;G&gt; {
    Template::new(&quot;time&quot;)
        .template(template_fn())
        // This page will revalidate every five seconds (to illustrate revalidation)
        // Try changing this to a week, even though the below custom logic says to always revalidate, we'll only do it weekly
        .revalidate_after(&quot;5s&quot;.to_string())
        .should_revalidate_fn(Rc::new(|| async { Ok(true) }))
        .build_state_fn(Rc::new(get_build_state))
}

pub async fn get_build_state(_path: String) -&gt; StringResultWithCause&lt;String&gt; {
    Ok(serde_json::to_string(&amp;TimePageProps {
        time: format!(&quot;{:?}&quot;, std::time::SystemTime::now()),
    })
    .unwrap())
}

pub fn template_fn&lt;G: GenericNode&gt;() -&gt; perseus::template::TemplateFn&lt;G&gt; {
    Rc::new(|props| {
        template! {
            TimePage(
                serde_json::from_str::&lt;TimePageProps&gt;(&amp;props.unwrap()).unwrap()
            )
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>If it were just <code>.should_revalidate_fn()</code> being called here, this page would always be rebuilt every time it's requested (the closure always returns <code>true</code>, note that errors would be <code>String</code>s), however, the additional usage of time-based revalidation regulates this, and the page will only be rebuilt every five seconds. In short, your arbitrary revalidation logic will only be executed at the intervals of your time-based revalidation intervals (if none are set, it will run on every request).</p>
<p>Note that you should avoid lengthy operations in revalidation if at all possible, as, like the <em>request state</em> strategy, this logic will be executed while the client is waiting for their page to load.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="incremental-generation"><a class="header" href="#incremental-generation">Incremental Generation</a></h1>
<p>Arguable the most powerful strategy in Perseus is <em>incremental generation</em>, which is an extension of <em>build paths</em> such that any path in the template's root path domain (more info on that concept <a href="strategies/../templates/intro.html">here</a>) will result in calling the <em>build state</em> strategy while the server is running.</p>
<p>A perfect example of this would be an retail site with thousands of products, all using the <code>product</code> template. If we built all these with <em>build paths</em>, and they all require fetching information from a database, builds could take a very long time. Instead, it's far more efficient to use <em>incremental generation</em>, which will allow any path under <code>/product</code> to call the <em>build state</em> strategy, which you can then use to render the product when it's first requested. This is on-demand building. But how is this different from the <em>request state</em> strategy? It caches the pages after they've been built the first time, meaning <strong>you build once on-demand, and then it's static generation from there</strong>. In other words, this strategy provides support for rendering thousands, millions, or even billions of pages from a single template while maintaining static generation times of less than a second!</p>
<p>Also, this strategy is fully compatible with <em>build paths</em>, meaning you could pre-render you most common pages at build-time, and have the rest built on-demand and then cached.</p>
<h2 id="usage-3"><a class="header" href="#usage-3">Usage</a></h2>
<p>This is the simplest strategy in Perseus to enable, needing only one line of code. Here's the example from earlier (which you can find <a href="https://github.com/arctic-hen7/perseus/blob/main/examples/showcase/src/templates/post.rs">here</a>) that uses <em>incremental generation</em> together with <em>build paths</em> (and of course <em>build state</em>, which is mandatory for <em>incremental generation</em> to work):</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perseus::{ErrorCause, StringResultWithCause, Template};
use serde::{Deserialize, Serialize};
use std::rc::Rc;
use sycamore::prelude::{component, template, GenericNode, Template as SycamoreTemplate};

#[derive(Serialize, Deserialize)]
pub struct PostPageProps {
    title: String,
    content: String,
}

#[component(PostPage&lt;G&gt;)]
pub fn post_page(props: PostPageProps) -&gt; SycamoreTemplate&lt;G&gt; {
    let title = props.title;
    let content = props.content;
    template! {
        h1 {
            (title)
        }
        p {
            (content)
        }
    }
}

pub fn get_template&lt;G: GenericNode&gt;() -&gt; Template&lt;G&gt; {
    Template::new(&quot;post&quot;)
        .build_paths_fn(Rc::new(get_static_paths))
        .build_state_fn(Rc::new(get_static_props))
        .incremental_generation()
        .template(template_fn())
}

pub async fn get_static_props(path: String) -&gt; StringResultWithCause&lt;String&gt; {
    // This path is illegal, and can't be rendered
    if path == &quot;post/tests&quot; {
        return Err((&quot;illegal page&quot;.to_string(), ErrorCause::Client(Some(404))));
    }
    // This is just an example
    let title = urlencoding::decode(&amp;path).unwrap();
    let content = format!(
        &quot;This is a post entitled '{}'. Its original slug was '{}'.&quot;,
        title, path
    );

    Ok(serde_json::to_string(&amp;PostPageProps {
        title: title.to_string(),
        content,
    })
    .unwrap())
}

pub async fn get_static_paths() -&gt; Result&lt;Vec&lt;String&gt;, String&gt; {
    Ok(vec![&quot;test&quot;.to_string(), &quot;blah/test/blah&quot;.to_string()])
}

pub fn template_fn&lt;G: GenericNode&gt;() -&gt; perseus::template::TemplateFn&lt;G&gt; {
    Rc::new(|props| {
        template! {
            PostPage(
                serde_json::from_str::&lt;PostPageProps&gt;(&amp;props.unwrap()).unwrap()
            )
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>All we need to do is run <code>.incremental_generation()</code> on the <code>Template</code>, and it's ready.</p>
<p>Note that this example throws a <em>404 Not Found</em> error if we go to <code>/post/tests</code>, which is considered an illegal URL. This is a demonstration of preventing certain pages from working with this strategy, and such filtering should be done in the <em>build state</em> strategy.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="state-amalgamation"><a class="header" href="#state-amalgamation">State Amalgamation</a></h1>
<p>In the introduction to this section, we mentioned that all these rendering strategies are compatible with one another, though we didn't explain how the two strategies that generate unique properties for a template can possible be compatible. That is, how can you use <em>build state</em> and <em>request state</em> in the same template? To our knowledge, Perseus is the only framework in the world (in any language) that supports using both, and it's made possible by <em>state amalgamation</em>, which lets you provide an arbitrary function that can merge conflicting states from these two strategies!</p>
<h2 id="usage-4"><a class="header" href="#usage-4">Usage</a></h2>
<p>Here's an example from <a href="https://github.com/arctic-hen7/perseus/blob/main/examples/showcase/src/templates/amalgamation.rs">here</a>:</p>
<pre><pre class="playground"><code class="language-rust no_run no-playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perseus::{Request, States, StringResultWithCause, Template};
use serde::{Deserialize, Serialize};
use std::rc::Rc;
use sycamore::prelude::{component, template, GenericNode, Template as SycamoreTemplate};

#[derive(Serialize, Deserialize, Debug)]
pub struct AmalagamationPageProps {
    pub message: String,
}

#[component(AboutPage&lt;G&gt;)]
pub fn about_page(props: AmalagamationPageProps) -&gt; SycamoreTemplate&lt;G&gt; {
    template! {
        p { (format!(&quot;The message is: '{}'&quot;, props.message)) }
    }
}

pub fn get_template&lt;G: GenericNode&gt;() -&gt; Template&lt;G&gt; {
    Template::new(&quot;amalgamation&quot;)
        .build_state_fn(Rc::new(get_build_state))
        .request_state_fn(Rc::new(get_request_state))
        .amalgamate_states_fn(Rc::new(amalgamate_states))
        .template(template_fn())
}

pub fn amalgamate_states(states: States) -&gt; StringResultWithCause&lt;Option&lt;String&gt;&gt; {
    // We know they'll both be defined
    let build_state =
        serde_json::from_str::&lt;AmalagamationPageProps&gt;(&amp;states.build_state.unwrap()).unwrap();
    let req_state =
        serde_json::from_str::&lt;AmalagamationPageProps&gt;(&amp;states.request_state.unwrap()).unwrap();

    Ok(Some(
        serde_json::to_string(&amp;AmalagamationPageProps {
            message: format!(
                &quot;Hello from the amalgamation! (Build says: '{}', server says: '{}'.)&quot;,
                build_state.message, req_state.message
            ),
        })
        .unwrap(),
    ))
}

pub async fn get_build_state(_path: String) -&gt; StringResultWithCause&lt;String&gt; {
    Ok(serde_json::to_string(&amp;AmalagamationPageProps {
        message: &quot;Hello from the build process!&quot;.to_string(),
    })
    .unwrap())
}

pub async fn get_request_state(_path: String, _req: Request) -&gt; StringResultWithCause&lt;String&gt; {
    // Err((&quot;this is a test error!&quot;.to_string(), perseus::ErrorCause::Client(None)))
    Ok(serde_json::to_string(&amp;AmalagamationPageProps {
        message: &quot;Hello from the server!&quot;.to_string(),
    })
    .unwrap())
}

pub fn template_fn&lt;G: GenericNode&gt;() -&gt; perseus::template::TemplateFn&lt;G&gt; {
    Rc::new(|props| {
        template! {
            AboutPage(
                serde_json::from_str::&lt;AmalagamationPageProps&gt;(&amp;props.unwrap()).unwrap()
            )
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>This example illustrates a very simple amalgamation, taking the states of both strategies to produce a new state that combines the two. Note that this also uses <code>StringResultWithCause</code> as a return type (see the section on the <a href="strategies/./build-state.html"><em>build state</em></a> strategy for more information). It will be passed an instance of <code>States</code>, which you can learn more about in the <a href="https://docs.rs/perseus">API docs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli"><a class="header" href="#cli">CLI</a></h1>
<p>One of the things that makes Perseus so different from most Rust frameworks is that it has its own CLI for development. The reason for this is to make using Perseus as simple as possible, and also because, if you have a look at what's in <code>.perseus/</code>, building without the CLI is really hard!</p>
<h2 id="commands"><a class="header" href="#commands">Commands</a></h2>
<h3 id="build"><a class="header" href="#build"><code>build</code></a></h3>
<p>Builds your app, performing static generation and preparing a Wasm package in <code>.perseus/dist/</code>.</p>
<h3 id="serve"><a class="header" href="#serve"><code>serve</code></a></h3>
<p>Builds your app in the same way as <code>build</code>, and then builds the Perseus server (which has dependencies on your code, and so needs to rebuilt on any changes just like the stuff in <code>.perseus/dist/</code>), finally serving your app at <a href="http://localhost:8080">http://localhost:8080</a>. You can change the default host and port this serves on with the <code>HOST</code> and <code>PORT</code> environment variables.</p>
<p>You can also provide <code>--no-build</code> to this command to make it skip building your app to Wasm and performing static generation. In this case, it will just build the serve rand run it (ideal for restarting the server if you've made no changes).</p>
<h3 id="clean"><a class="header" href="#clean"><code>clean</code></a></h3>
<p>This command is the solution to just about any problem in your app that doesn't make sense, it deletes the <code>.perseus/</code> directory entirely, which should remove any corruptions! If this doesn't work, then the problem is in your code (unless you just updated to a new version and now something doesn't work, then it's probably on us, please <a href="https://github.com/arctic-hen7/perseus">open an issue</a>!).</p>
<p>Note that this command will force Perseus to rebuild <code>.perseus/</code> the next time you run <code>perseus build</code> or <code>perseus serve</code>, which can be annoying in terms of build times. It's almost always sufficient to run this command with the <code>--dist</code> flag, which will only delete some content in <code>.perseus/dist/</code> that's likely to be problematic.</p>
<h3 id="eject"><a class="header" href="#eject"><code>eject</code></a></h3>
<p>See the next section for the details of this command.</p>
<h2 id="watching"><a class="header" href="#watching">Watching</a></h2>
<p>Right now, the Perseus CLI doesn't support watching files for changes and rebuilding, but it soon will. Until then, you can replicate this behavior with a tool like <a href="https://github.com/eradman/entr"><code>entr</code></a> or the equivalent. Anything that watches file and reruns commands when they change will work for this.</p>
<p>Here's an example of watching files with <code>entr</code>:</p>
<pre><code>find . -not -path &quot;./.perseus/*&quot; -not -path &quot;./target/*&quot; | entr -s &quot;perseus serve&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ejecting"><a class="header" href="#ejecting">Ejecting</a></h1>
<p>The Perseus CLI is fantastic at enabling rapid and efficient development, but sometimes it can be overly restrictive. If there's a use-case that the CLI doesn't seem to support, please <a href="https://github.com/arctic-hen7/perseus/issues/new/choose">open an issue</a> on GitHub, and we'll look into supporting it out-of-the-box.</p>
<p>However, there are some things that are too advanced for the CLI to support, and, in those cases, you'll need to eject. Don't worry, you'll still be able to use the CLI itself for running your app, but you'll be given access to the engine that underlies it, and you'll be able to tweak basically anything you want.</p>
<p><em>Note: ejecting from Perseus exposes the bones of the system, and you should be quite familiar with Rust before doing this. That said, if you're just doing it for fun, go right ahead!</em></p>
<h2 id="ejecting-1"><a class="header" href="#ejecting-1">Ejecting</a></h2>
<p><code>perseus eject</code></p>
<p>This command does two things: it removes <code>.perseus/</code> from your <code>.gitignore</code> file, and it adds a new file called <code>.perseus/.ejected</code>.</p>
<p>After ejecting, there are a few things that change.</p>
<ul>
<li>You can no longer run <code>perseus clean</code> unless you provide the <code>--dist</code> flag (otherwise it would delete the engine you're tweaking!)</li>
<li>A ton of files appear in Git that you should commit, all from <code>.perseus/</code></li>
</ul>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>Under the hood, Perseus' CLI is only responsible for running commands like <code>cargo run</code> and <code>wasm-pack build</code>. All the logic is done in <code>.perseus/</code>, which provides two crates, one for your app itself (which also contains a binary for running static generation) and another for the server that will run your app. That means that you can still use the CLI!</p>
<p>One of the first things you'll probably want to do if you choose to eject is to remove the <code>[workspace]</code> declaration from <code>.perseus/Cargo.toml</code> and instead add both crates inside to your project's workspace. This will make sure that linters like RLS will check your modifications to <code>.perseus/</code> for any problems, and you won't be flying blind.</p>
<p>The rest of the documentation on how Perseus works under the hood can be found in the <em>Advanced</em> section of the book, which you'll want to peruse if you choose to eject.</p>
<h2 id="reversing-ejection"><a class="header" href="#reversing-ejection">Reversing Ejection</a></h2>
<p>If, after taking a look at the innards, you decide that you'd like to find a solution for your problem that works without having to perform what can easily seem like the programming equivalent of brain surgery, you can easily reverse ejection by deleting the <code>.perseus/.ejected</code> file and running <code>perseus clean</code>, which will permanently delete your modifications and allow you to start again with a clean slate. Note that the reversal of ejection is irreversible, so it pays to have a backup of your changes in case you want to check something later!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="config-managers"><a class="header" href="#config-managers">Config Managers</a></h1>
<p>Perseus generates a number of files in its build process, which allow it to make your app extremely performant on the client and the server. By default, these are stored under <code>.perseus/dist/</code>, however there may be cases in which you want to store these files elsewhere, particularly given that <strong>they need to modified at runtime</strong>. While not recommended, it may be necessary in some deployments to move these files to a database or CMS. Note that this will have a notable performance impact on your app, and the default is always recommended.</p>
<p>That said, Perseus allows you to store content wherever you'd like with the <code>ConfigManager</code> trait, the default implementation of which is <code>FsConfigManager</code>, which takes a directory to use. Very similar to the <a href="">translations manager</a> system, you can customize the options to this by providing your own instance of it under <code>define_app!</code>'s <code>config_manager</code> property, or you can build your own for interfacing with a non-filesystem storage apparatus. To do the latter, you'll need to consult <a href="https://github.com/arctic-hen7/perseus/blob/main/packages/perseus/src/config_manager.rs">this file</a>, and, if you're stuck, don't hesitate to ask a question under <a href="https://github.com/arctic-hen7/perseus/discussions/new">discussions</a> on GitHub!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>When building a web app, testing is extremely important, and also extremely helpful. If you're familiar with Rust, you're probably used to having two types of tests (unit tests and integration tests), but Perseus follows the JavaScript model of testing slightly more, which is better suited to a user-facing web app, and has three types of tests:</p>
<ul>
<li>Unit tests -- same as in Rust, they test a small amount of logic in isolation</li>
<li>Integration tests -- same as in Rust, they test the system itself, but sometimes mocking things like a database</li>
<li>End-to-end tests -- not mocking anything at all, and fully testing the entire system as if a real user were operating it</li>
</ul>
<p>It's that last type that Perseus is particularly concerned with, because that's the way that you can create highly resilient web apps that are tested for real user interaction. In fact, most of Perseus itself is tested this way! Also, E2E tests are more effective at automating otherwise manual testing of going through a browser and checking that things work, and they're far less brittle than any other type of test (all that matters is the final user experience).</p>
<p>In terms of unit tests, these can be done for normal logic (that doesn't render something) with Rust's own testing system. Any integration tests, as well as unit tests that do render things, should be done with <a href="https://rustwasm.github.io/wasm-bindgen/wasm-bindgen-test/index.html"><code>wasm-bindgen-test</code></a>. This module provides a custom <em>test harness</em> macro (alternative to <code>#[test]</code>) that spins up a <em>headless browser</em> (browser without a GUI) that can be used to render your code. Note that this should be done for testing Sycamore components, and not for testing integrated Perseus systems.</p>
<p>When you want to test logic flows in your app, like the possibilities of how a user will interact with a login form, the best way is to use end-to-end testing, which Perseus supports with a custom test harness macro that can be used like so (taken from <a href="https://github.com/arctic-hen7/perseus/blob/main/examples/basic/tests/main.rs">here</a>):</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">use fantoccini::{Client, Locator};
use perseus::wait_for_checkpoint;

#[perseus::test]
async fn main(c: &amp;mut Client) -&gt; Result&lt;(), fantoccini::error::CmdError&gt; {
    c.goto(&quot;http://localhost:8080&quot;).await?;
    wait_for_checkpoint!(&quot;begin&quot;, 0, c);
    let url = c.current_url().await?;
    assert!(url.as_ref().starts_with(&quot;http://localhost:8080&quot;));

    // The greeting was passed through using build state
    wait_for_checkpoint!(&quot;initial_state_present&quot;, 0, c);
    wait_for_checkpoint!(&quot;page_visible&quot;, 0, c);
    let greeting = c.find(Locator::Css(&quot;p&quot;)).await?.text().await?;
    assert_eq!(greeting, &quot;Hello World!&quot;);
    // For some reason, retrieving the inner HTML or text of a `&lt;title&gt;` doens't work
    let title = c.find(Locator::Css(&quot;title&quot;)).await?.html(false).await?;
    assert_eq!(title, &quot;&lt;title&gt;Index Page | Perseus Example ‚Äì Basic&lt;/title&gt;&quot;);

    // Go to `/about`
    c.find(Locator::Id(&quot;about-link&quot;)).await?.click().await?;
    let url = c.current_url().await?;
    assert!(url.as_ref().starts_with(&quot;http://localhost:8080/about&quot;));
    wait_for_checkpoint!(&quot;initial_state_not_present&quot;, 0, c);
    wait_for_checkpoint!(&quot;page_visible&quot;, 1, c);
    // Make sure the hardcoded text there exists
    let text = c.find(Locator::Css(&quot;p&quot;)).await?.text().await?;
    assert_eq!(text, &quot;About.&quot;);
    let title = c.find(Locator::Css(&quot;title&quot;)).await?.html(false).await?;
    assert_eq!(title, &quot;&lt;title&gt;About Page | Perseus Example ‚Äì Basic&lt;/title&gt;&quot;);
    // Make sure we get initial state if we refresh
    c.refresh().await?;
    wait_for_checkpoint!(&quot;initial_state_present&quot;, 0, c);

    Ok(())
}
</code></pre></pre>
<p>The first thing to note is the module that this test imports. It's called <a href="https://github.com/jonhoo/fantoccini">Fantoccini</a>, and it basically lets you control a web browser with code. We'll get to exactly how this works soon. This test goes to <a href="http://localhost:8080">http://localhost:8080</a> (where a Perseus app is hosted) and then clicks a link on it and makes sure that it's been taken to the correct new URL.</p>
<p>The other important thing to note is the signature of this test function. First, it's annotated with <code>#[perseus::test]</code>, which means this will expand into a larger function that makes your function work. It takes a Fantoccini client as a parameter (which we've called <code>c</code> for convenience, you'll use it a lot), and returns a result. <strong>In Perseus E2E tests, you shouldn't panic, but return an error gracefully instead</strong>, which gives the harness time to disconnect from the headless browser. If you don't do this, you'll leave the browser in limbo, and other connections will fail, and everything will blow up in your face. Note that <code>assert!</code>, <code>assert_eq!</code>, and <code>assert_ne!</code> do <code>panic!</code> if they fail, which will cause the browser to be left in limbo.</p>
<h2 id="writing-a-test"><a class="header" href="#writing-a-test">Writing a Test</a></h2>
<p>You can write your own tests by creating files of whatever names you'd like under <code>test/</code> in your project's root directory (as you would with traditional Rust integration tests), and then you can write tests like the above example. Don't worry if you stuff up the arguments or the return type slightly, Perseus will let you know. Also note that <strong>test functions must be asynchronous</strong>.</p>
<p>You'll also need to add the following to your <code>Cargo.toml</code> (<code>tokio</code> is needed for running your tests asynchronously):</p>
<pre><code class="language-toml">[dev-dependencies]
fantoccini = &quot;0.17&quot;
tokio = { version = &quot;1&quot;, features = [&quot;macros&quot;, &quot;rt&quot;, &quot;rt-multi-thread&quot;] }
</code></pre>
<h2 id="running-tests"><a class="header" href="#running-tests">Running Tests</a></h2>
<p>Perseus tests can be run with <code>cargo test</code> as usual, but you'll need to provide the <code>PERSEUS_RUN_WASM_TESTS</code> environment variable as true. This makes sure that you don't accidentally run tests that have external dependencies (like a headless browser). Note that, by default, your tests will run in a full browser, so you'll get GUI windows opening on  your screen that are controlled by your tests. These can be extremely useful for debugging, but they're hardly helpful on CI, so you can remove them and run <em>headlessly</em> (without a GUI window) by providing the <code>PERSEUS_RUN_WASM_TESTS_HEADLESS</code> environment variable.</p>
<p>Before running E2E tests, you need to have two things running in the background:</p>
<ul>
<li>Something that allows you to interact with a headless browser using the <em>WebDriver</em> protocol (see below)</li>
<li>Your app, invoked with <code>perseus test</code> (different to <code>perseus serve</code>)</li>
</ul>
<details>
<summary>How would I automate all that?</summary>
<p>It may be most convenient to create a shell script to do these for you, or to use a tool like <a href="https://github.com/arctic-hen7/bonnie">Bonnie</a> to automate the process. You can see an example of how this is done for a large number of tests across multiple different example apps in the <a href="https://github.com/arctic-hen7/perseus">Perseus repository</a>.</p>
</details>
<p><em>Note: Cargo runs your tests in parallel by default, which won't work with some WebDrivers, like Firefox's <code>geckodriver</code>. To run your tests sequentially instead (slower), use <code>cargo test -- --test-threads 1</code> (this won't keep your tests in the same order though, but that's generally unnecessary).</em></p>
<h2 id="webdrivers"><a class="header" href="#webdrivers">WebDrivers?</a></h2>
<p>So far, we've mostly gone through this without explaining the details of a headless browser, which will be necessary to have some basic understanding of. Your web browser is composed a huge number of complex moving parts, and these are perfect for running end-to-end tests. They have rendering engines, Wasm execution environments, etc. Modern browsers support certain protocols that allow them to be controlled by code, and this can be done through a server like <a href="https://selenium.dev">Selenium</a>. In the case of Perseus though, we don't need something quite so fancy, and a simple system like <a href="https://github.com/mozilla/geckodriver"><code>geckodriver</code></a> for Firefox or <a href="https://chromedriver.chromium.org/"><code>chromedriver</code></a> for Chromium/Chrome will do fine.</p>
<p>If you're completely new to headless browsers, here's a quick how-to guide with Firefox so we're all on the same page (there are similar steps for Google Chrome as well):</p>
<ol>
<li>Install <a href="https://firefox.com">Firefox</a>.</li>
<li>Install <a href="https://github.com/mozilla/geckodriver"><code>geckodriver</code></a>. On Ubuntu, this can be done with <code>sudo apt install firefox-geckodriver</code>.</li>
<li>Run <code>geckodriver</code> in a terminal window on its own and run your Perseus tests elsewhere.</li>
<li>Press Ctrl+C in the <code>geckodriver</code> terminal when you're done.</li>
</ol>
<p><em>Note: if your WebDriver instance is running somewhere other than <a href="http://localhost:4444">http://localhost:4444</a>, you can specify that with <code>#[perseus::test(webdriver_url = &quot;custom-url-here&quot;)]</code>.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checkpoints"><a class="header" href="#checkpoints">Checkpoints</a></h1>
<p>If you start using Perseus' testing system now, you'll likely hit a snag very quickly, involving errors to do with <em>stale DOM elements</em>. This is an unfortunate side-effect of the way Perseus currently handles initial loads (we move a number of DOM elements around after they've been sent down from the server), which results in the WebDriver thinking half the page has just disappeared out from under it!</p>
<p>This, and many similar problems, are easily solvable using one of Perseus' most powerful testing tools: <em>checkpoints</em>. When you run your app with <code>perseus test</code>, a system is enabled in the background that writes a new DOM element to a hidden list of them when any app code calls <code>checkpoint()</code>. This can then be detected with Fantoccini! Admittedly, a far nicer solution would be DOM events, but the WebDriver protocol doesn't yet support listening for them (understandable since it's mimicking a user's interaction with the browser).</p>
<p>Note that checkpoints will never be reached if your app is not run with <code>perseus test</code>. If you use <code>--no-run</code> and then execute the server binary manually, be sure to provide the <code>PERSEUS_TESTING=true</code> environment variable.</p>
<p>You can wait for a Perseus checkpoint to be reached like so (taken from <a href="https://github.com/arctic-hen7/perseus/blob/main/examples/basic/tests/main.rs">here</a>):</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">use fantoccini::{Client, Locator};
use perseus::wait_for_checkpoint;

#[perseus::test]
async fn main(c: &amp;mut Client) -&gt; Result&lt;(), fantoccini::error::CmdError&gt; {
    c.goto(&quot;http://localhost:8080&quot;).await?;
    wait_for_checkpoint!(&quot;begin&quot;, 0, c);
    let url = c.current_url().await?;
    assert!(url.as_ref().starts_with(&quot;http://localhost:8080&quot;));

    // The greeting was passed through using build state
    wait_for_checkpoint!(&quot;initial_state_present&quot;, 0, c);
    wait_for_checkpoint!(&quot;page_visible&quot;, 0, c);
    let greeting = c.find(Locator::Css(&quot;p&quot;)).await?.text().await?;
    assert_eq!(greeting, &quot;Hello World!&quot;);
    // For some reason, retrieving the inner HTML or text of a `&lt;title&gt;` doens't work
    let title = c.find(Locator::Css(&quot;title&quot;)).await?.html(false).await?;
    assert_eq!(title, &quot;&lt;title&gt;Index Page | Perseus Example ‚Äì Basic&lt;/title&gt;&quot;);

    // Go to `/about`
    c.find(Locator::Id(&quot;about-link&quot;)).await?.click().await?;
    let url = c.current_url().await?;
    assert!(url.as_ref().starts_with(&quot;http://localhost:8080/about&quot;));
    wait_for_checkpoint!(&quot;initial_state_not_present&quot;, 0, c);
    wait_for_checkpoint!(&quot;page_visible&quot;, 1, c);
    // Make sure the hardcoded text there exists
    let text = c.find(Locator::Css(&quot;p&quot;)).await?.text().await?;
    assert_eq!(text, &quot;About.&quot;);
    let title = c.find(Locator::Css(&quot;title&quot;)).await?.html(false).await?;
    assert_eq!(title, &quot;&lt;title&gt;About Page | Perseus Example ‚Äì Basic&lt;/title&gt;&quot;);
    // Make sure we get initial state if we refresh
    c.refresh().await?;
    wait_for_checkpoint!(&quot;initial_state_present&quot;, 0, c);

    Ok(())
}
</code></pre></pre>
<p>Note in particular the use of the <code>wait_for_checkpoint!</code> macro, which accepts three arguments:</p>
<ul>
<li>Name of the checkpoint</li>
<li>Version of the checkpoint</li>
<li>Fantoccini client</li>
</ul>
<p>For want of a better term, that second argument refers to how Perseus manages checkpoints. Because a single checkpoint might be emitted multiple times, Perseus attaches a number to the end of each. The final element <code>id</code> looks like this: <code>__perseus_checkpoint-&lt;checkpoint_name&gt;-&lt;number&gt;</code>, where <code>&lt;number&gt;</code> starts from 0 and increments.</p>
<p><em>Note: checkpoints are not cleared until the page is fully reloaded, so clicking a link to another page will not clear them!</em></p>
<h2 id="custom-checkpoints"><a class="header" href="#custom-checkpoints">Custom Checkpoints</a></h2>
<p>In addition to Perseus' internal checkpoints (listed below), you can also use your own checkpoints, though they must follow the following criteria:</p>
<ul>
<li>Must not include hyphens (used as a delimiter character), use underscores instead</li>
<li>Must not conflict with an internal Perseus checkpoint name</li>
</ul>
<p>The best way to uphold the latter of those criteria is to prefix your own checkpoints with something like the name of your app, or even just <code>custom_</code>. Of course, if your app has a name like <code>router</code>, then that will be a problem (many Perseus checkpoints begin with <code>router_</code>), but Perseus will never generate checkpoints internally that begin with <code>custom_</code>.</p>
<p>Note that it's not enough to make sure that your checkpoints don't clash with any existing checkpoints, as new checkpoints may be added in any new release of Perseus, so conflicts may arise with the tiniest of updates!</p>
<h2 id="internal-checkpoints"><a class="header" href="#internal-checkpoints">Internal Checkpoints</a></h2>
<p>Perseus has a number of internal checkpoints that are listed below. Note that this list will increase over time, and potentially in patch releases.</p>
<ul>
<li><code>begin</code> -- when the Perseus system has been initialized</li>
<li><code>router_entry</code> -- when the Perseus router has reached a verdict and is about to either render a new page, detect the user's locale and redirect, or show an error page</li>
<li><code>not_found</code> -- when the page wasn't found</li>
<li><code>app_shell_entry</code> -- when the page was found and it's being rendered</li>
<li><code>initial_state_present</code> -- when the page has been rendered for the first time, and the server has preloaded everything (see <a href="testing/../advanced/initial-loads.html">here</a> for details)</li>
<li><code>page_visible</code> -- when the user is able to see page content (but the page isn't interactive yet)</li>
<li><code>page_interactive</code> -- when the page has been hydrated, and is now interactive</li>
<li><code>initial_state_not_present</code> -- when the initial state is not present, and the app shell will need to fetch page data from the server</li>
<li><code>initial_state_error</code> -- when initial state showed an error</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fantoccini-basics"><a class="header" href="#fantoccini-basics">Fantoccini Basics</a></h1>
<p>Now that you know a bit more about how Perseus tests work, it's time to go through how to write them!</p>
<p>Remember, you're controlling an actual browser, so you basically have everything available to you that a user can do (mostly). You can even take screenshots! All this is achieved with <a href="https://github.com/jonhoo/fantoccini">Fantoccini</a>, which you can learn more about <a href="https://docs.rs/fantoccini">here</a>. For now though, here's a quick tutorial on the basics, using <a href="https://github.com/arctic-hen7/perseus/blob/main/examples/basic/tests/main.rs">this</a> example:</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">use fantoccini::{Client, Locator};
use perseus::wait_for_checkpoint;

#[perseus::test]
async fn main(c: &amp;mut Client) -&gt; Result&lt;(), fantoccini::error::CmdError&gt; {
    c.goto(&quot;http://localhost:8080&quot;).await?;
    wait_for_checkpoint!(&quot;begin&quot;, 0, c);
    let url = c.current_url().await?;
    assert!(url.as_ref().starts_with(&quot;http://localhost:8080&quot;));

    // The greeting was passed through using build state
    wait_for_checkpoint!(&quot;initial_state_present&quot;, 0, c);
    wait_for_checkpoint!(&quot;page_visible&quot;, 0, c);
    let greeting = c.find(Locator::Css(&quot;p&quot;)).await?.text().await?;
    assert_eq!(greeting, &quot;Hello World!&quot;);
    // For some reason, retrieving the inner HTML or text of a `&lt;title&gt;` doens't work
    let title = c.find(Locator::Css(&quot;title&quot;)).await?.html(false).await?;
    assert_eq!(title, &quot;&lt;title&gt;Index Page | Perseus Example ‚Äì Basic&lt;/title&gt;&quot;);

    // Go to `/about`
    c.find(Locator::Id(&quot;about-link&quot;)).await?.click().await?;
    let url = c.current_url().await?;
    assert!(url.as_ref().starts_with(&quot;http://localhost:8080/about&quot;));
    wait_for_checkpoint!(&quot;initial_state_not_present&quot;, 0, c);
    wait_for_checkpoint!(&quot;page_visible&quot;, 1, c);
    // Make sure the hardcoded text there exists
    let text = c.find(Locator::Css(&quot;p&quot;)).await?.text().await?;
    assert_eq!(text, &quot;About.&quot;);
    let title = c.find(Locator::Css(&quot;title&quot;)).await?.html(false).await?;
    assert_eq!(title, &quot;&lt;title&gt;About Page | Perseus Example ‚Äì Basic&lt;/title&gt;&quot;);
    // Make sure we get initial state if we refresh
    c.refresh().await?;
    wait_for_checkpoint!(&quot;initial_state_present&quot;, 0, c);

    Ok(())
}
</code></pre></pre>
<h2 id="going-to-a-page"><a class="header" href="#going-to-a-page">Going to a Page</a></h2>
<p>You can trivially go to a page of your app by running <code>c.goto(&quot;...&quot;)</code>. The above example ensures that the URL is valid, but you shouldn't have to do this unless you're testing a page that automatically redirects the user. Also, if you're using <a href="testing/../i18n/intro.html">i18n</a>, don't worry about testing automatic locale redirection, we've already done that for you!</p>
<p>Once you've arrived at a page, you should wait for the <code>router_entry</code> (this example uses <code>begin</code> because it tests internal parts of Perseus) checkpoint, which will be reached when Perseus has decided what to do with your app. If you're testing particular page logic, you should wait instead for <code>page_visible</code>, which will be reached when the user could see content on your page, and then for <code>page_interactive</code>, which will be reached when the page is completely ready. Remember though, you only need to wait for the checkpoints that you actually use (e.g. you don't need to wait for <code>page_visible</code> and <code>page_interactive</code> if you're not doing anything in between).</p>
<h2 id="finding-an-element"><a class="header" href="#finding-an-element">Finding an Element</a></h2>
<p>You can find an element easily by using Fantoccini's <code>Locator</code> <code>enum</code>. This has two options, <code>Id</code> or <code>Css</code>. The former will find an element by its HTML <code>id</code>, and the latter will use a CSS selector (<a href="https://www.w3schools.com/cssref/css_selectors.asp">here</a>'s a list of them). In the above example, we've used <code>Locator::Css(&quot;p&quot;)</code> to get all paragraph elements, and then we've plugged that into <code>c.find()</code> to get the first one. Then, we can get its <code>innerText</code> with <code>.text()</code> and assert that is what we want it to be.</p>
<h3 id="caveats"><a class="header" href="#caveats">Caveats</a></h3>
<p>As you may have noticed above, asserting on the contents of a <code>&lt;title&gt;</code> is extremely unintuitive, as it requires using <code>.html(false)</code> (meaning include the element tag itself) and asserting against that. For some reason, neither <code>.html(true)</code> nor <code>.text()</code> return anything. There's a tracking issue for this <a href="https://github.com/jonhoo/fantoccini/issues/136">here</a>.</p>
<h2 id="miscellaneous"><a class="header" href="#miscellaneous">Miscellaneous</a></h2>
<p>For full documentation of how Fantoccini works, see its API documentation <a href="https://docs.rs/fantoccini">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manual-testing"><a class="header" href="#manual-testing">Manual Testing</a></h1>
<p>Occasionally, the Perseus testing harness may be a little too brittle for your needs, particularly if you'd like to pass custom arguments to the WebDriver (e.g. to spoof media streams). In these cases, you'll want to break out of it entirely and work with Fantoccini manually.</p>
<p>You should do this by wrapping your normal test function in another function and annotating that with <code>[tokio::test]</code>, which will mark it as a normal asynchronous test. Then, you can mimic the behavior of the Perseus test harness almost exactly with the following code (adapted from the macro <a href="https://github.com/arctic-hen7/perseus/blob/main/packages/perseus-macro/src/test.rs">here</a>):</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Only run the test if the environment variable is specified (avoids having to do exclusions for workspace `cargo test`)
if ::std::env::var(&quot;PERSEUS_RUN_WASM_TESTS&quot;).is_ok() {
    let headless = ::std::env::var(&quot;PERSEUS_RUN_WASM_TESTS_HEADLESS&quot;).is_ok();
    // Set the capabilities of the client
    let mut capabilities = ::serde_json::Map::new();
    let firefox_opts;
    let chrome_opts;
    if headless {
        firefox_opts = ::serde_json::json!({ &quot;args&quot;: [&quot;--headless&quot;] });
        chrome_opts = ::serde_json::json!({ &quot;args&quot;: [&quot;--headless&quot;] });
    } else {
        firefox_opts = ::serde_json::json!({ &quot;args&quot;: [] });
        chrome_opts = ::serde_json::json!({ &quot;args&quot;: [] });
    }
    capabilities.insert(&quot;moz:firefoxOptions&quot;.to_string(), firefox_opts);
    capabilities.insert(&quot;goog:chromeOptions&quot;.to_string(), chrome_opts);

    let mut client = ::fantoccini::ClientBuilder::native()
        .capabilities(capabilities)
        .connect(&amp;&quot;http://localhost:4444&quot;).await.expect(&quot;failed to connect to WebDriver&quot;);
    let output = fn_internal(&amp;mut client).await;
    // Close the client no matter what
    client.close().await.expect(&quot;failed to close Fantoccini client&quot;);
    // Panic if the test failed
    if let Err(err) = output {
        panic!(&quot;test failed: '{}'&quot;, err.to_string())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Then, you can relatively easily modify the properties sent to the WebDriver instance with <code>firefox_opts</code> and <code>chrome_opts</code>. You can see the documentation for their options <a href="https://developer.mozilla.org/en-US/docs/Web/WebDriver/Capabilities/firefoxOptions">here</a> (Firefox) and <a href="https://sites.google.com/a/chromium.org/chromedriver/capabilities">here</a> (Chrome/Chromium).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="styling"><a class="header" href="#styling">Styling</a></h1>
<blockquote>
<p>Note: Perseus uses <a href="https://github.com/sycamore-rs/sycamore">Sycamore</a> for writing views, and styling is still <a href="https://sycamore-rs.netlify.app/docs/v0.6/advanced/css">in development</a> there.</p>
</blockquote>
<p>Perseus aims to make styling as easy as possible, though there are a number of things that you should definitely know about before you start to style a Perseus app!</p>
<p>It's very easy to import stylesheets with Perseus (be they your own, something like <a href="https://tailwindcss.com">TailwindCSS</a>, etc.). You just add them to the <code>static/</code> directory at the root of your project, and then they'll be available at <code>/.perseus/static/your-filename-here</code>. That's described in more detail in <a href="./static-content.html">this section</a>.</p>
<h2 id="full-page-layouts"><a class="header" href="#full-page-layouts">Full-Page Layouts</a></h2>
<p>If you've tried to create something like a stick footer, you've probably become extremely frustrated by Perseus, which puts all your content in a container <code>&lt;div&gt;</code> (in addition to the <code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code>). Unfortunately, this is necessary until Sycamore supports creating a template for an existing DOM node, and this does lead to some styling problems.</p>
<p>Notably, there are actually two of these <code>&lt;div&gt;</code>s at the moment: one for the content that the server pre-renders in <a href="./advanced/initial-loads.html">initial loads</a> and another for when that content is hydrated by Perseus' client-side logic. That means that, if you only style one of these, you'll get a horrible flash of unstyled content, which nobody wants. To make this as easy as possible, Perseus provides a class <code>__perseus_content</code> that applies to both of these <code>&lt;div&gt;</code>s. Also, note that the <code>&lt;div&gt;</code> for the initial content will become <code>display: none;</code> as soon as the page is ready, which means you won't get it interfering with your layouts.</p>
<p>Knowing this, the main changes you'll need to make to any full-page layout code is to apply the styles to <code>.__perseus_content</code> instead of <code>body</code> or <code>#root</code>. As with CSS generally, if you expect <code>.__perseus_content</code> to take up the whole page, you'll need to make all its parents (<code>#root</code>, <code>body</code>, <code>html</code>) also take up the whole page (you can do this by setting <code>height: 100vh;</code> on <code>body</code>).</p>
<p>Any other issues should be solvable by inspecting the DOM with your browser's DevTools, but you're more than welcome to ask for help on the <a href="https://discord.gg/PgwPn7dKEk">Sycamore Discord server</a>, where Perseus has its own channel!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploying"><a class="header" href="#deploying">Deploying</a></h1>
<p>Perseus is a complex system, but we aim to make deploying it as easy as possible. This section will describe a few different types of Perseus deployments, and how they can be managed.</p>
<p><em>Note: Perseus deployment is still under design and development, so this information in particular is subject to rapid change before v1.0.0.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="static-exporting"><a class="header" href="#static-exporting">Static Exporting</a></h1>
<p>The easiest way to deploy Perseus is as a set of static files, which is supported if your app uses only the <em>build state</em> and <em>build paths</em> strategies, or none at all. If you use <em>incremental generation</em>, <em>revalidation</em>, or <em>request state</em> in any of your templates though, you can't export your app to static file, because these strategies require a custom server. For these cases, please continue to the rest of this section to learn how to deploy your more complex setup.</p>
<p>However, if your app only needs to run server-side computations at build-time, then you can export it to a set of static files without changing anything, simply by running <code>perseus export</code>. This will create a new directory called <code>.perseus/dist/exported</code>, the contents of which can be served on a system like <a href="https:://pages.github.com">GitHub Pages</a>. Your app should behave in the exact same way with exporting as with normal serving. If this isn't the case, please <a href="https://github.com/arctic-hen7/perseus/issues/new/choose">open an issue</a>.</p>
<p>There is only one known difference between the behavior of your exported site and your normally served site, and that's regarding <a href="deploying/../static-content.html">static aliases</a>. In a normal serving scenario, any static aliases that conflicted with a Perseus page or internal asset would be ignored, but, in an exporting context, <strong>any static aliases that conflict with Perseus pages will override them</strong>! If you suspect this might be happening to you, try exporting without those aliases and make sure the URL of your alias file doesn't already exist (in which case it would be a Perseus component).</p>
<h2 id="file-extensions"><a class="header" href="#file-extensions">File Extensions</a></h2>
<p>One slight hiccup with Perseus' static exporting system comes with regards to the <code>.html</code> file extension. Perseus' server expects that pages shouldn't have such extensions (hence <code>/about</code> rather than <code>/about.html</code>), but, when statically generated, they must have these extensions in the filesystem. So, if you don't want these extensions for your users (and if you want consistent behavior between exporting and serving), it's up to whatever system you're hosting your files with to strip these extensions. Many systems do this automatically, though some (like Python's <code>http.server</code>) do not.</p>
<p>One of the best systems for testing static exporting on your local machine is the <a href="https://github.com/versel/serve"><code>serve</code></a> JavaScript package, which can be run from the command-line without touching any JavaScript, and it handles this problem automatically. However, other solutions certainly exist if you don't want any JS polluting your system!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migrating-from-v01x"><a class="header" href="#migrating-from-v01x">Migrating from v0.1.x</a></h1>
<p>Perseus v0.2.0 added a <em>huge</em> number of features, fixed a number of bugs, improved performance and SEO, and made Perseus significantly easier to use. If you're currently running v0.1.x, here's how to upgrade!</p>
<p><em>Note: if possible, it's best to start a new project for Perseus v0.2.0 due to the sheer number of changes that have occurred.</em></p>
<ol>
<li>Update your <code>Cargo.toml</code> dependencies for <code>perseus</code> to <code>0.2</code>.</li>
<li>Remove dependencies on <code>perseus-actix-web</code> and <code>sycamore-router</code> that you might have had before (fully internal now).</li>
<li>Upgrade the Perseus CLI with <code>cargo install perseus-cli</code>.</li>
<li>Run <code>perseus clean</code> to remove the old <code>.perseus/</code> directory.</li>
<li>Change all <code>Rc</code>s to <code>Arc</code>s.</li>
<li>Change your <code>lib.rs</code> to match the <a href="./define-app.html">new <code>define_app!</code> macro</a> and delete routing code (all that is now inferred, with no extra code from you)!.</li>
<li>Update your code for the remaining breaking changes listed in <a href="">the CHANGELOG</a>.</li>
</ol>
<p><em>Note: if you're running an older machine (pre-2015), it may be worth setting the <code>PERSEUS_CLI_SEQUENTIAL</code> environment variable to <code>true</code> to disable the CLI's new multi-threading, which may overly burden older systems. You should try it first to make sure though.</em></p>
<h2 id="upgrading-from-a-non-cli-project"><a class="header" href="#upgrading-from-a-non-cli-project">Upgrading from a Non-CLI Project</a></h2>
<p>If you were running Perseus v0.1.x and not using the CLI, upgrading your existing app will be almost impossible due to significant infrastructural changes, and you should try to migrate your code over to a v0.2.0 CLI project, which will be faster and far easier to work with.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="under-the-hood"><a class="header" href="#under-the-hood">Under the Hood</a></h1>
<p>This section of the documentation is devoted to explaining the inner workings of Perseus, which will be particularly useful if you choose to eject from the CLI's harness or if you want to contribute to Perseus!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h1>
<p>Perseus has five main components:</p>
<ul>
<li><code>perseus</code> -- the core module that defines everything necessary to build a Perseus app if you try hard enough</li>
<li><code>perseus-actix-web</code> -- an integration that makes it easy to run Perseus on the <a href="https://actix.rs">Actix Web</a> framework</li>
<li><code>perseus-cli</code> -- the command-line interface used to run Perseus apps conveniently</li>
<li><code>perseus-cli-builder</code> -- an internal crate created by the CLI responsible for building an app</li>
<li><code>perseus-cli-server</code> -- an internal crate created by the CLI responsible for serving an app and performing runtime logic</li>
</ul>
<h2 id="core"><a class="header" href="#core">Core</a></h2>
<p>At the core of Perseus is the <a href="https://docs.rs/perseus"><code>perseus</code></a> module, which is used for nearly everything in Perseus. In theory, you could build a fully-functional app based on this crate alone, but you'd be reinventing the wheel at least three times. This crate exposes types for the i18n systems, configuration management, routing, and asset fetching, most of which aren't intended to be used directly by the user.</p>
<p>What is intended to be used directly is the <code>Template&lt;G&gt;</code> <code>struct</code>, which is integral to Perseus. This stores closures for every rendering strategy, which are executed as provided and necessary at build and runtime. Note that these are all stored in <code>Rc</code>s, and <code>Template&lt;G&gt;</code>s are cloned.</p>
<p>The other commonly used system from this crate is the <code>Translator</code> system, explained in detail in <a href="advanced/../i18n/intro.html">the i18n section</a>. <code>Translator</code>s are passed around in <code>Rc</code>s, and <code>TranslationsManager</code> on the server caches all translations by default in memory on the server.</p>
<h2 id="actix-web-integration"><a class="header" href="#actix-web-integration">Actix Web Integration</a></h2>
<p>The core of Perseus provides very few systems to set up a functional Perseus server though, which requires a significant amount of additional work. To this end, <a href="https://docs.rs/perseus-actix-web"><code>perseus-actix-web</code></a> is used to make this process easy. If you've ejected, you'll be working with this directly, which should be relatively simple, as it just accepts configuration options and then should simply work.</p>
<p>Note that this module provides a <code>configurer</code> function, which allows it to be modularly added to any existing Actix Web server, which is particularly useful if you want to run other endpoint on your server, or a system like <a href="https://github.com/arctic-hen7/diana">Diana</a>.</p>
<h2 id="cli-1"><a class="header" href="#cli-1">CLI</a></h2>
<p>As documented in <a href="advanced/../cli.html">this section</a>, the CLI simply runs commands to execute the last two components of the Perseus system, acting as a convenience. It also contains these two components inside its binary (using <a href="https://github.com/Michael-F-Bryan/include_dir"><code>include_dir!</code></a>)</p>
<h2 id="cli-builder"><a class="header" href="#cli-builder">CLI Builder</a></h2>
<p>This system can be further broken down into two parts.</p>
<h3 id="static-generator"><a class="header" href="#static-generator">Static Generator</a></h3>
<p>This is a single binary that just imports the user's templates and some other information (like locales) and then calls <code>build_app</code>. This will result in generating a number of files to <code>.perseus/dist</code>, which will be served by the server to any clients, which will then hydrate those static pages into fully-fledged Sycamore templates.</p>
<h3 id="app-shell"><a class="header" href="#app-shell">App Shell</a></h3>
<p>This is encapsulated in <code>.perseus/src/lib.rs</code>, and it performs a number of integral functions:</p>
<ul>
<li>Ensures that any <code>panic!</code>s or the like ar printed properly in the browser console</li>
<li>Creates and manages the internal router</li>
<li>Renders your actual app</li>
<li>Handles locale detection</li>
<li>Invokes the core app shell to manage initial/subsequent loads and translations</li>
<li>Handles error page displaying</li>
</ul>
<h2 id="cli-server"><a class="header" href="#cli-server">CLI Server</a></h2>
<p>This is just an invocation of the <code>perseus-actix-web</code> module's systems with the data provided by the user through the <code>define_app!</code> macro. This also sets the default location for static content and the <code>index.html</code> file.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initial-loads"><a class="header" href="#initial-loads">Initial Loads</a></h1>
<p>Perseus handles <em>initial loads</em> very differently from <em>subsequent loads</em>. The former refers to what's done when a user visits a page on a Perseus app from an external source (e.g. visiting from a search engine, redirected from another site), and this requires a full HTMl page to be sent that can be interpreted by the browser. By contrast, subsequent loads are loads between pages within the same Perseus app, which can be performed by the app shell (described in the next section).</p>
<p>The process of initial loads is slightly complex, and occurs like so (this example is for a page called <code>/posts/test</code>, rendered with incremental generation):</p>
<ol>
<li>Browser requests <code>/posts/test</code> from the server.</li>
<li>Server matches requested URL to wildcard (<code>*</code>) and handles it with the server-side inferred router, determining which <code>Template&lt;G&gt;</code> to use.</li>
<li>Server calls internal core methods to render the page (using incremental generation strategy, but it doesn't need to know that), producing an HTML snippet and a set of JSON properties.</li>
<li>Server calls <code>template.render_head_str()</code> and injects the result into the document's <code>&lt;head&gt;</code> (avoiding <code>&lt;title&gt;</code> flashes and improving SEO) after a delimiter comment that separates it from the metadata on every page (which is hardcoded into <code>index.html</code>).</li>
<li>Server interpolates JSON state into <code>index.html</code> as a global variable in a <code>&lt;script&gt;</code>.</li>
<li>Server interpolates HTML snippet directly into the user's <code>index.html</code> file.</li>
<li>Server sends final HTML package to client, including Wasm (injected at build-time).</li>
<li>Browser renders HTML package, user sees content immediately.</li>
<li>Browser invokes Wasm, hands control to the app shell.</li>
<li>App shell checks if initial state declaration global variable is present, finds that it is and unsets it (so that it doesn't interfere with subsequent loads).</li>
<li>App shell moves server-rendered content out of <code>__perseus_content_initial</code> and into <code>__perseus_content_rx</code>, which Sycamore's router had control over (allowing it to catch links and use the subsequent loads system).</li>
<li>App shell gets a translator if the app uses i18n.</li>
<li>App shell hydrates content at <code>__perseus_content_rx</code> with Sycamore and returns, the page is now interactive and has a translator context.</li>
</ol>
<p>Note: if this app had used i18n, the server would've returned the app shell with no content, and the app shell, when invoked, would've immediately redirected the user to their preferred locale (or the closest equivalent).</p>
<p>The two files integral to this process are <a href="https://github.com/arctic-hen7/perseus/blob/main/packages/perseus-actix-web/src/initial_load.rs"><code>initial_load.rs</code></a> and <a href="https://github.com/arctic-hen7/perseus/blob/main/packages/perseus/src/shell.rs"><code>shell.rs</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subsequent-loads"><a class="header" href="#subsequent-loads">Subsequent Loads</a></h1>
<p>if the user follows a link inside a Perseus app to another page within that same app, the Sycamore router will catch it and prevent the browser from requesting the new file from the server. The following will then occur (for an <code>/about</code> page rendered simply):</p>
<ol>
<li>Sycamore router calls Perseus inferred router logic.</li>
<li>Perseus inferred router determines from new URL that template <code>about</code> should be used, returns to Sycamore router.</li>
<li>Sycamore router passes that to closure in <code>perseus-cli-builder</code> shell, which executes core app shell.</li>
<li>App shell checks if an initial load declaration global variable is present and finds none, hence it will proceed with the subsequent load system.</li>
<li>App shell fetches page data from <code>/.perseus/page/&lt;locale&gt;/about?template_name=about</code> (if the app isn't using i18n, <code>&lt;locale&gt;</code> will verbatim be <code>xx-XX</code>).</li>
<li>Server checks to ensure that locale is supported.</li>
<li>Server renders page using internal systems (in this case that will just return the static HTML file from <code>.perseus/dist/static/</code>).</li>
<li>Server renders document <code>&lt;head&gt;</code>.</li>
<li>Server returns JSON of HTML snippet (not complete file), stringified properties, and head.</li>
<li>App shell deserializes page data into state and HTML snippet.</li>
<li>App shell interpolates HTML snippet directly into <code>__perseus_content_rx</code> (which Sycamore router controls), user can now see new page.</li>
<li>App shell interpolates new document <code>&lt;head&gt;</code>.</li>
<li>App shell initializes translator if the app is using i18n.</li>
<li>App shell hydrates content at <code>__perseus_content_rx</code>, page is now interactive.</li>
</ol>
<p>The two files integral to this process are <a href="https://github.com/arctic-hen7/perseus/blob/main/packages/perseus-actix-web/src/page_data.rs"><code>page_data.rs</code></a> and <a href="https://github.com/arctic-hen7/perseus/blob/main/packages/perseus/src/shell.rs"><code>shell.rs</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="routing-2"><a class="header" href="#routing-2">Routing</a></h1>
<p>Perseus' routing system is quite unique in that it's almost entirely <em>inferred</em>, meaning that you don't ever have to define a router or explain to the system which paths go where. Instead, they're inferred from templates in a system that's explained in detail in the <a href="advanced/../templates/intro.html">templates section</a>.</p>
<h2 id="template-selection-algorithm"><a class="header" href="#template-selection-algorithm">Template Selection Algorithm</a></h2>
<p>Perseus has a very specific algorithm that it uses to determine which template to use for a given route, which is greatly dependent on <code>.perseus/dist/render_conf.json</code>. This is executed on the client-side for <em>subsequent loads</em> and on the server-side for <em>initial loads</em>.</p>
<p>Here's an example render configuration (for the <a href="https://github.com/arctic-hen7/perseus/blob/main/examples/showcase">showcase example</a>), which maps path to template root path.</p>
<pre><code class="language-json">{
    &quot;about&quot;: &quot;about&quot;,
    &quot;index&quot;: &quot;index&quot;,
    &quot;post/new&quot;: &quot;post/new&quot;,
    &quot;ip&quot;: &quot;ip&quot;,
    &quot;post/*&quot;: &quot;post&quot;,
    &quot;timeisr/test&quot;: &quot;timeisr&quot;,
    &quot;timeisr/*&quot;: &quot;timeisr&quot;,
    &quot;time&quot;: &quot;time&quot;,
    &quot;amalgamation&quot;: &quot;amalgamation&quot;,
    &quot;post/blah/test/blah&quot;: &quot;post&quot;,
    &quot;post/test&quot;: &quot;post&quot;
}
</code></pre>
<p>Here are the algorithm's steps (see <a href="https://github.com/arctic-hen7/perseus/blob/main/packages/perseus/src/router.rs"><code>router.rs</code></a>):</p>
<ol>
<li>If the path is empty, set it to <code>index</code> (which is used for the landing page).</li>
<li>Try to directly get the template name by trying the path as a key. This would work for anything not using incremental generation (in the above example, anything other than <code>post/*</code>).</li>
<li>Split the path into sections by <code>/</code> and iterate through them, performing the following on each section (iterating forwards from the beginning of the path, becoming more and more specific):
<ol>
<li>Make a path out of all segments up to the current point, adding <code>/*</code> at the end (indicative of incremental generation in the render configuration).</li>
<li>Try that as a key, return if it works.</li>
<li>Even if we have something, continue iterating until we have nothing. This way, we get the most specific path possible (and we can have incremental generation in incremental generation).</li>
</ol>
</li>
</ol>
<h2 id="relationship-with-sycamores-router"><a class="header" href="#relationship-with-sycamores-router">Relationship with Sycamore's Router</a></h2>
<p>Sycamore has its own <a href="https://sycamore-rs.netlify.app/docs/v0.6/advanced/routing">routing system</a>, which Perseus depends on extensively under the hood. This is evident in <code>.perseus/src/lib.rs</code>, which invokes the router. However, rather than using the traditional Sycamore approach of having an <code>enum</code> with variants for each possible route (which was the approach in Perseus v0.1.x), Perseus provides the router with a <code>struct</code> that performs routing logic and returns either <code>RouteVerdict::Found</code>, <code>RouteVerdict::LocaleDetection</code>, or <code>RouteVerdict::NotFound</code>. The render configuration is accessed through a global variable implanted in the user's HTML shell when the server initializes.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
