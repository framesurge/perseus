
<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Perseus Book</title>
        <meta name="robots" content="noindex" />
        

    <!-- Custom HTML head -->
    

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
            <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
    
    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
    
    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    
    </head>

<body>
    <!-- Provide site root to javascript -->
    <script type="text/javascript">
        var path_to_root = "";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script type="text/javascript">
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');
            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }
            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script type="text/javascript">
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = default_theme; }
        var html = document.querySelector('html');
        html.classList.remove('no-js')
        html.classList.remove('light')
        html.classList.add(theme);
        html.classList.add('js');
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script type="text/javascript">
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="what-is-perseus.html"><strong aria-hidden="true">1.1.</strong> What is Perseus?</a></li><li class="chapter-item expanded "><a href="hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello World!</a></li></ol></li><li class="chapter-item expanded "><a href="second-app.html"><strong aria-hidden="true">2.</strong> Your Second App</a></li></ol>        </div>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
            <div id="menu-bar-hover-placeholder"></div>
            <style>
    header.warning {
        background-color: rgb(242, 222, 222);
        border-bottom-color: rgb(238, 211, 215);
        border-bottom-left-radius: 4px;
        border-bottom-right-radius: 4px;
        border-bottom-style: solid;
        border-bottom-width: 0.666667px;
        border-image-outset: 0 0 0 0;
        border-image-repeat: stretch stretch;
        border-image-slice: 100% 100% 100% 100%;
        border-image-source: none;
        border-image-width: 1 1 1 1;
        border-left-color: rgb(238, 211, 215);
        border-left-style: solid;
        border-left-width: 0.666667px;
        border-right-color: rgb(238, 211, 215);
        border-right-style: solid;
        border-right-width: 0.666667px;
        border-top-color: rgb(238, 211, 215);
        border-top-left-radius: 4px;
        border-top-right-radius: 4px;
        border-top-style: solid;
        border-top-width: 0.666667px;
        color: rgb(185, 74, 72);
        padding-bottom: 8px;
        padding-left: 14px;
        padding-right: 35px;
        padding-top: 8px;
        text-align: center;
        margin-bottom: 0px;
        margin-left: 0px;
        margin-right: 0px;
        margin-top: 30px;
    }
</style>
<header class="warning">
    This documentation is for the <strong>unpublished</strong> next version of Perseus,
    and features documented here may not yet be available in the existing releases.
    <br>
    You can find documentation for the most recently released version of Perseus
    <a href="https://arctic-hen7.github.io/perseus/stable.html">here</a>.
</header>

            <div id="menu-bar" class="menu-bar sticky bordered">
                <div class="left-buttons">
                    <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button>
                        </li>
                    </ul>
                                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                        aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                        aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                                    </div>

                <h1 class="menu-title">Perseus Book</h1>

                <div class="right-buttons">
                                        <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                                                            
                </div>
            </div>

                        <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                        aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>
            
            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script type="text/javascript">
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                });
            </script>

            <div id="content" class="content">
                <main>
                    <h1 id="welcome-to-perseus"><a class="header" href="#welcome-to-perseus">Welcome to Perseus!</a></h1>
<p><a href="https://github.com/arctic-hen7/perseus">Home</a> ‚Ä¢ <a href="https://crates.io/crates/perseus">Crate Page</a> ‚Ä¢ <a href="https://docs.rs/perseus">API Documentation</a> ‚Ä¢ <a href="./CONTRIBUTING.html">Contributing</a></p>
<p>Welcome to the Perseus documentation! Here, you'll find guides on how to use Perseus, as well as documentation for specific features and plenty of examples!</p>
<p>If you like Perseus, please consider giving us a star <a href="https://github.com/arctic-hen7/perseus">on GitHub</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-perseus"><a class="header" href="#what-is-perseus">What is Perseus?</a></h1>
<p>If you're familiar with <a href="https://nextjs.org">NextJS</a>, Perseus is that for Wasm. If you're familiar with <a href="https://kit.svelte.dev">SvelteKit</a>, it's that for <a href="https://github.com/sycamore-rs/sycamore">Sycamore</a>.</p>
<p>If none of that makes any sense, this is the section for you! If you're not in the mood for a lecture, <a href="what-is-perseus.html#summary">here's a TL;DR</a>!</p>
<h3 id="rust-web-development"><a class="header" href="#rust-web-development">Rust web development</a></h3>
<p><a href="https://www.rust-lang.org/">Rust</a> is an extremely powerful programming language, but I'll leave the introduction of it <a href="https://www.rust-lang.org/">to its developers</a>.</p>
<p><a href="https://webassembly.org">WebAssembly</a> (abbreviated Wasm) is like a low-level programming language for your browser. This is revolutionary, because it allows websites and web apps to built in programming languages other than JavaScript. Also, it's <a href="https://medium.com/@torch2424/webassembly-is-fast-a-real-world-benchmark-of-webassembly-vs-es6-d85a23f8e193">really fast</a> (usually &gt;30% faster than JS).</p>
<p>But developing directly for the web with Rust using something like <a href="https://docs.rs/web-sys"><code>web-sys</code></a> isn't a great experience, it's generally agreed in the web development community that developer experience and productivity is vastly improved by having a <em>reactive</em> framework. Let's approach this from a traditional JavaScript and HTML perspective first.</p>
<p>Imagine you want to create a simple counter. Here's how you might do it in a non-reactive framework (again, JS and HTML here, no Rust yet):</p>
<pre><code class="language-html">&lt;p id=&quot;counter&quot;&gt;0&lt;/p&gt;&lt;br/&gt;
&lt;button onclick=&quot;document.getElementById('counter').innerHTML = parseInt(document.getElementById('counter').innerHTML) + 1&quot;&gt;Increment&lt;/button&gt;
</code></pre>
<p>If you're unfamiliar with HTML and JS, don't worry. All this does is create a paragraph with a number inside and then increment it. But the problem is clear in terms of expression: why can't we just put a variable in the paragraph and have that re-render when we increment that variable? Well, that's reactivity!</p>
<p>In JS, there are frameworks like <a href="https://svelte.dev">Svelte</a> and <a href="https://reactjs.org">ReactJS</a> that solve this problem, but they're all bound significantly by the language itself. JavaScript is slow, dynamically typed, and <a href="https://medium.com/netscape/javascript-is-kinda-shit-im-sorry-2e973e36fec4">a bit of a mess</a>. Like all things to do with the web, changing things is really difficult because people have already started using them, and there will always be <em>someone</em> still using Internet Explorer, which supports almost no modern web standards at all.</p>
<p><a href="https://webassembly.org">Wasm</a> solves all these problems by creating a unified format that other programming languages, like Rust, can compile into for the browser environment. This makes websites safer, faster, and development more productive. The equivalent of these reactive frameworks for Rust in particular would be projects like <a href="https://sycamore-rs.netlify.app">Sycamore</a>, <a href="https://seed-rs.org">Seed</a>, and <a href="https://yew.rs">Yew</a>. Sycamore is the most extensible and low-level of those options, and it's more performant because it doesn't use a <a href="https://svelte.dev/blog/virtual-dom-is-pure-overhead">virtual DOM</a> (link about JS rather than Rust), and so it was chosen to be the backbone of Perseus. Here's what that counter might look like in <a href="https://sycamore-rs.netlify.app">Sycamore</a> (the incrementation has been moved into a new closure for convenience):</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sycamore::prelude::*;

let counter = Signal::new(0);
let increment = cloned!((counter) =&gt; move |_| counter.set(*counter.get() + 1));

template! {
    p {(props.greeting)}
    a(href = &quot;/about&quot;) { &quot;About!&quot; }

    p { (counter.get()) }
    button(on:click = increment) { &quot;Increment&quot; }
}
<span class="boring">}
</span></code></pre></pre>
<p>You can learn more about Sycamore's amazing systems <a href="https://sycamore-rs.netlify.app">here</a>.</p>
<h3 id="this-sounds-good"><a class="header" href="#this-sounds-good">This sounds good...</a></h3>
<p>But there's a catch to all this: rendering. With all these approaches in Rust so far (except for a few mentioned later), all your pages are rendered <em>in the user's browser</em>. That means your users have to download your Wasm code and run it before they see anything at all on their screens. Not only does that increase your loading time (<a href="https://medium.com/@vikigreen/impact-of-slow-page-load-time-on-website-performance-40d5c9ce568a">which can drive away users</a>), it reduces your search engine rankings as well.</p>
<p>This can be solved through <em>server-side rendering</em> (SSR), which means that we render pages on the server and send them to the client, which means your users see something very quickly, and then it becomes <em>interactive</em> (usable) a moment later. This is better for user retention (shorter loading times) and SEO (search engine optimization).</p>
<p>The traditional approach to SSR is to wait for a request for a particular page (say <code>/about</code>), and then render it on the server and send that to the client. This is what <a href="https://seed-rs.org">Seed</a> (an alternative to Perseus) does. However, this means that your website's <em>time to first byte</em> (TTFB) is slower, because the user won't even get <em>anything</em> from the server until it has finished rendering. In times of high load, that can drive loading times up worryingly.</p>
<p>The solution to this is <em>static site generation</em> (SSG), whereby your pages are rendered <em>at build time</em>, and they can be served almost instantly on any request. This approach is fantastic, and thus far widely unimplemented in Rust. The downside to this is that you don't get as much flexibility, because you have to render everything at build time. That means you don't have access to any user credentials or anything else like that. Every page you render statically has to be the same for every user.</p>
<p>Perseus supports SSR <em>and</em> SSG out of the box, along with the ability to use both on the same page, rebuild pages after a certain period of time (e.g. to update a list of blog posts every 24 hours) or based on certain conditions (e.g. if the hash of a file has changed), or even to statically build pages on demand (the first request is SSR, all the rest are SSG), meaning you can get the best of every world and faster build times.</p>
<p>To our knowledge, the only other framework in the world right now that supports this feature set is <a href="https://nextjs.org">NextJS</a> (with growing competition from <a href="https://www.gatsbyjs.com">GatsbyJS</a>), which only works with JavaScript. Perseus goes above and beyond this for Wasm by supporting whole new combinations of rendering options not previously available, allowing you to create optimized websites and web apps extremely efficiently.</p>
<h2 id="how-fast-is-it"><a class="header" href="#how-fast-is-it">How fast is it?</a></h2>
<p><a href="https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts-results/table.html">Benchmarks show</a> that <a href="https://sycamore-rs.netlify.app">Sycamore</a> is slightly faster than <a href="https://svelte.dev">Svelte</a> in places, one of the fastest JS frameworks ever. Perseus uses it and <a href="https://actix.rs">Actix Web</a>, one of the fastest web servers in the world. Essentially, Perseus is built on the fastest tech and is itself made to be fast.</p>
<p>Right now, Perseus is undergoing major improvements to make it even faster and to introduce new features, like support for internationalization (making your app available in many languages) out of the box, which involves significant changes to the code. Once these are ready, benchmarks for Perseus itself will be written to show how fast Perseus really is, but right now none exist.</p>
<h2 id="how-convenient-is-it"><a class="header" href="#how-convenient-is-it">How convenient is it?</a></h2>
<p>Perseus aims to be more convenient than any other Rust web framework by taking an approach similar to that of <a href="https://reactjs.org">ReactJS</a>. Perseus itself is an extremely complex system consisting of many moving parts that can all be brought together to create something amazing, but the vast majority of apps don't need all that customizability, so we built a command-line interface (CLI) that handles all that complexity for you, allowing you to focus entirely on your app's code.</p>
<p>Basically, here's your workflow:</p>
<ol>
<li>Create a new project.</li>
<li>Define your app in under 30 lines of code (coming down to 15 with v0.2.0!)</li>
<li>Code your amazing app.</li>
<li>Run <code>perseus serve</code>.</li>
</ol>
<h2 id="how-stable-is-it"><a class="header" href="#how-stable-is-it">How stable is it?</a></h2>
<p>Okay, there had to be one caveat! Perseus is <em>very</em> new, and as such can't be recommended for <em>production</em> usage yet. However, we're aiming to get it ready for that really soon, which will hopefully include even being able to deploy Perseus with <a href="https://en.wikipedia.org/wiki/Serverless_computing">serverless functions</a>, the step beyond a server!</p>
<p>For now though, Perseus is perfect for anything that doesn't face the wider internet, like internal tools, personal projects, or the like. Just don't use it to run a nuclear power plant, okay?</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>If all that was way too long, here's a quick summary of what Perseus does and why it's useful!</p>
<ul>
<li>JS is slow and a bit of a mess, <a href="https://webassembly.org">Wasm</a> lets you run most programing languages, like Rust, in the browser, and is really fast</li>
<li>Doing web development without reactivity is really annoying, so <a href="https://sycamore-rs.netlify.app">Sycamore</a> is great</li>
<li>Perseus lets you render your app on the server, making the client's experience <em>really</em> fast, and adds a ton of features to make that possible, convenient, and productive (even for really complicated apps)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World!</a></h1>
<p>Let's get started with Perseus!</p>
<p><em>To follow along here, you'll want to be familiar with Rust, which you can learn more about <a href="https://rust-lang.org">here</a>. You should also have it and <code>cargo</code> installed.</em></p>
<p>To begin, create a new folder for your project, let's call it <code>my-perseus-app</code>. Now, create a <code>Cargo.toml</code> file in that folder. This tells Rust which packages you want to use in your project and some other metadata. Put the following inside:</p>
<pre><code class="language-toml">[package]
name = &quot;my-perseus-app&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
perseus = &quot;0.2&quot;
sycamore = &quot;0.6&quot;
</code></pre>
<details>
<summary>What are those dependencies doing?</summary>
<ul>
<li><code>perseus</code> -- the core module for Perseus</li>
<li><a href="https://github.com/sycamore-rs/sycamore"><code>sycamore</code></a> -- the amazing system on which Perseus is built, this allows you to write reactive web apps in Rust</li>
</ul>
<p>Note that we've set these dependencies up so that they'll automatically update <em>patch versions</em>, which means we'll get bug fixes automatically, but we won't get any updates that will break our app!</p>
</details>
<p>Now, create an <code>index.html</code> file at the root of your project and put the following inside:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
        &lt;title&gt;Perseus Example ‚Äì Tiny&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<details>
<summary>Why do I need an HTML file?</summary>
<p>Perseus aims to be as versatile as possible, and so it allows you to include your own <code>index.html</code> file, in which you can import things like fonts, analytics, etc.</p>
<p>This file MUST contain at least the following:</p>
<ul>
<li><code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code>, which is where your app will be rendered, this must be a <code>&lt;div&gt;</code> with no other attributes except the <code>id</code>, and that spacing (that way parsing is lightweight and fast)</li>
<li>A <code>&lt;head&gt;</code>, which is where HTML metadata goes (even if you don't have any metadata, Perseus still needs it)</li>
</ul>
<p>Note also that we don't have to import anything to make Perseus run here, the server will do that automatically for us!</p>
</details>
<p>Now, create a new directory called <code>src</code> and add a new file inside called <code>lib.rs</code>. Put the following inside:</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perseus::{define_app, ErrorPages, Template};
use std::rc::Rc;
use sycamore::template;
define_app! {
    templates: [
        Template::&lt;G&gt;::new(&quot;index&quot;).template(Rc::new(|_| {
            template! {
                p { &quot;Hello World!&quot; }
            }
        }))
    ],
    error_pages: ErrorPages::new(Rc::new(|url, status, err, _| {
        template! {
            p { (format!(&quot;An error with HTTP code {} occurred at '{}': '{}'.&quot;, status, url, err)) }
        }
    }))
}
<span class="boring">}
</span></code></pre></pre>
<details>
<summary>How does that work?</summary>
<p>First, we import some things that'll be useful:</p>
<ul>
<li><code>perseus::{define_app, ErrorPages, Template}</code> -- the -<code>define_app!</code> macro, which tells Perseus how your app works; the <code>ErrorPages</code> <code>struct</code>, which lets you tell Perseus how to handle errors (like <em>404 Not Found</em> if the user goes to a nonexistent page); and the <code>Template</code> <code>struct</code>, which is how Perseus manages pages in your app</li>
<li><code>std::rc::Rc</code> -- a <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html">reference-counted smart pointer</a> (you don't <em>have</em> to understand these to use Perseus, but reading that link would be helpful)</li>
<li><code>sycamore::template</code> -- Sycamore's [<code>template!</code> macro], which lets you write HTML-like code in Rust</li>
</ul>
<p>Then, we use the <code>define_app!</code> macro to declare the different aspects of the app, starting with the <em>templates</em>. We only have one template, which we've called <code>index</code> (a special name that makes it render at the root of your app), and then we define how that should look, creating a paragraph (<code>p</code>) containing the text <code>Hello World!</code>. Perseus does all kinds of clever stuff with this under the hood, and we put it in an <code>Rc</code> to enable that.</p>
<p>Finally, we tell Perseus what to do if something in your app fails, like if the user goes to a page that doesn't exist. This requires creating a new instance of <code>ErrorPages</code>, which is a <code>struct</code> that lets you define a separate error page for every <a href="https://httpstatuses.com">HTTP status code</a>, as well as a fallback. Here, we've just defined the fallback. That page is given the URL that caused the error, the HTTP status code, and the actual error message, all of which we display with a Sycamore <code>template!</code>, with seamless interpolation.</p>
</details>
<p>Now install the Perseus CLI with <code>cargo install perseus-cli</code> (you'll need <code>wasm-pack</code> to let Perseus build your app, use <code>cargo install wasm-pack</code> to install it) to make your life way easier, and deploy your app to <a href="http://localhost:8080">http://localhost:8080</a> by running <code>perseus serve</code> inside the root of your project! This will take a while the first time, because it's got to fetch all your dependencies and build your app.</p>
<details>
<summary>Why do I need a CLI?</summary>
<p>Perseus is a <em>very</em> complex system, and, if you had to write all that complexity yourself, that <em>Hello World!</em> example would be more like 1700 lines of code than 17! The CLI lets you abstract away all that complexity into a directory that you might have noticed appear called <code>.perseus/</code>. If you take a look inside, you'll actually find two crates (Rust packages): one for your app, and another for the server that serves your app. These are what actually run your app, and they import the code you've written. The <code>define_app!</code> macro defines a series of functions and constants at compile-time that make this possible.</p>
<p>When you run <code>perseus serve</code>, the <code>.perseus/</code> directory is created and added to your <code>.gitignore</code>, and then three stages occur in parallel (they're shown in your terminal):</p>
<ul>
<li><em>üî® Generating your app</em> -- here, your app is built to a series of static files in <code>.perseus/dist/static</code>, which makes your app lightning-fast (your app's pages are ready before it's even been deployed, which is called <em>static site generation</em>, or SSG)</li>
<li><em>üèóÔ∏è Building your app to Wasm</em> -- here, your app is built to <a href="">WebAssembly</a>, which is what lets a low-level programming language like Rust run in the browser</li>
<li><em>üì° Building server</em> -- here, Perseus builds its internal server based on your code, and prepares to serve your app</li>
</ul>
<p>The first time you run this command, it can take quite a while to get everything ready, but after that it'll be really fast. And, if you haven't changed any code (<em>at all</em>) since you last ran it, you can run <code>perseus serve --no-build</code> to run the server basically instantaneously.</p>
</details>
<p>Once that's done, hop over to <a href="http://localhost:8080">http://localhost:8080</a> in any modern browser (not Internet Explorer...), and you should see <em>Hello World!</em> printed on the screen! If you try going to <a href="http://localhost:8080/about">http://localhost:8080/about</a> or any other page, you should see a message that tells you the page wasn't found.</p>
<p>Congratulations! You've just created your first ever Perseus app! You can see the source code for this section <a href="https://github.com/arctic-hen7/perseus/tree/main/examples/tiny">here</a>.</p>
<h2 id="moving-forward"><a class="header" href="#moving-forward">Moving Forward</a></h2>
<p>The next section creates a slightly more realistic app with more than just one file, which will show you how a Perseus app is usually structured.</p>
<p>After that, you'll learn how different features of Perseus work, like <em>incremental generation</em> (which lets you build pages on-demand at runtime)!</p>
<h3 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h3>
<p>If you've gone through this and you aren't that chuffed with Perseus, here are some similar projects in Rust:</p>
<ul>
<li><a href="https://github.com/sycamore-rs/sycamore">Sycamore</a> (without Perseus) -- <em>A reactive library for creating web apps in Rust and WebAssembly.</em></li>
<li><a href="https://github.com/yewstack/yew">Yew</a> -- <em>Rust/Wasm framework for building client web apps.</em></li>
<li><a href="https://github.com/seed-rs/seed">Seed</a> -- <em>A Rust framework for creating web apps.</em></li>
<li><a href="https://github.com/chinedufn/percy">Percy</a> -- <em>Build frontend browser apps with Rust + WebAssembly. Supports server side rendering.</em></li>
<li><a href="https://github.com/MoonZoon/MoonZoon">MoonZoon</a> -- <em>Rust Fullstack Framework.</em></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-second-app"><a class="header" href="#your-second-app">Your Second App</a></h1>
<p>This section will cover building a more realistic app than the <em>Hello World!</em> section, with proper structuring and multiple templates.</p>
<p>If learning by reading isn't really your thing, or you'd like a reference, you can see all the code in <a href="https://github.com/arctic-hen7/perseus/tree/main/examples/basic">this repository</a>!</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>Much like the <em>Hello World!</em> app, we'll start off by creating a new directory for the project, maybe <code>my-second-perseus-app</code> (or you could exercise imagination...). Then, we'll create a new <code>Cargo.toml</code> file and fill it with the following:</p>
<pre><code class="language-toml">[package]
name = &quot;my-second-perseus-app&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
perseus = &quot;0.2&quot;
sycamore = &quot;0.6&quot;
serde = { version = &quot;1&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1&quot;
</code></pre>
<p>The only difference between this and the last <code>Cargo.toml</code> we created is two new dependencies:</p>
<ul>
<li><a href="https://serde.rs"><code>serde</code></a> -- a really useful Rust library for serializing/deserializing data</li>
<li><a href="https://github.com/serde-rs/json"><code>serde_json</code></a> -- Serde's integration for JSON, which lets us pass around properties for more advanced pages in Perseus</li>
</ul>
<p>The next thing to do is to create <code>index.html</code>, which is pretty much the same as last time:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>The only notable difference here is the absence of a <code>&lt;title&gt;</code>, which is because we'll be creating it inside Perseus! Any Perseus template can modify the <code>&lt;head&gt;</code> of the document, but anything you put into <code>index.html</code> will persist across all pages. We don't want to have conflicting titles, so we leave that property out of <code>index.html</code>.</p>
<h2 id="librs"><a class="header" href="#librs"><code>lib.rs</code></a></h2>
<p>As in every Perseus app, <code>lib.rs</code> is how we communicate with the CLI and tell it how our app works. Put the following content in <code>src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust no_playground no_run edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod error_pages;
mod templates;

use perseus::define_app;

define_app! {
    templates: [
        crate::templates::index::get_template::&lt;G&gt;(),
        crate::templates::about::get_template::&lt;G&gt;()
    ],
    error_pages: crate::error_pages::get_error_pages(),
    static_aliases: {
        &quot;/test.txt&quot; =&gt; &quot;static/test.txt&quot;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This code is quite different from your first app, so let's go through how it works.</p>
<p>First, we define two other modules in our code: <code>error_pages</code> (at <code>src/error_pages.rs</code>) and <code>templates</code> (at <code>src/templates</code>). Don't worry, we'll create those in a moment. The rest of the code creates a new app with two templates, which are expected to be in the <code>src/templates</code> directory. Note the use of <code>&lt;G&gt;</code> here, which is a Rust <em>type parameter</em> (the <code>get_template</code> function can work for the browser or the server, so Rust needs to know which one it is). This parameter is <em>ambient</em> to the <code>templates</code> key, which means you can use it without declaring it as long as you're inside <code>templates: {...}</code>. This will be set to <code>DomNode</code> for the browser and <code>SsrNode</code> for the server, but that all happens behind the scenes.</p>
<p>Also note that we're pulling in our error pages from another file as well (in a larger app you may even want to have a different file for each error page).</p>
<p>The last thing we do is new, we define <code>static_aliases</code> to map the URL <code>/test.txt</code> in our app to the file <code>static/test.txt</code>. This feature is detailed in more depth later, but it can be extremely useful, for example for defining your site's logo (or favicon), which browsers expect to be available at <code>/favicon.ico</code>. Create the <code>static/test.txt</code> file now (<code>static/</code> should NOT be inside <code>src/</code>!) and fill it with whatever you want.</p>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>Before we get to the cool part of building the actual pages of the app, we should set up error pages again, which we'll do in <code>src/error_pages.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perseus::{ErrorPages, GenericNode};
use std::rc::Rc;
use sycamore::template;

pub fn get_error_pages&lt;G: GenericNode&gt;() -&gt; ErrorPages&lt;G&gt; {
    let mut error_pages = ErrorPages::new(Rc::new(|url, status, err, _| {
        template! {
            p { (format!(&quot;An error with HTTP code {} occurred at '{}': '{}'.&quot;, status, url, err)) }
        }
    }));
    error_pages.add_page(
        404,
        Rc::new(|_, _, _, _| {
            template! {
                p { &quot;Page not found.&quot; }
            }
        }),
    );

    error_pages
}
<span class="boring">}
</span></code></pre></pre>
<p>This is a little more advanced than the last time we did this, and there are a few things we should note.</p>
<p>The first is the import of <code>GenericNode</code>, which we define as a type parameter on the <code>get_error_pages</code> function. As we said before, this means your error pages will work on the client or the server, and they're needed in both environments. If you're interested, this separation of browser and server elements is done by Sycamore, and you can learn more about it <a href="https://docs.rs/sycamore/0.6/sycamore/generic_node/trait.GenericNode.html">here</a>.</p>
<p>In this function, we also define a different error page for a 404 error, which will occur when a user tries to go to a page that doesn't exist. The fallback page (which we initialize <code>ErrorPages</code> with) is the same as last time, and will be called for any errors other than a <em>404 Not Found</em>.</p>
<h2 id="indexrs"><a class="header" href="#indexrs"><code>index.rs</code></a></h2>
<p>It's time to create the first page for this app! But first, we need to make sure that import in <code>src/lib.rs</code> of <code>mod templates;</code> works, which requires us to create a new file <code>src/templates/mod.rs</code>, which declares <code>src/templates</code> as a module with its own code. Add the following to that file:</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod about;
pub mod index;
<span class="boring">}
</span></code></pre></pre>
<p>It's common practice to have a file for each <em>template</em>, which is slightly different to a page (explained in more detail later), and this app has two pages: a landing page (index) and an about page.</p>
<p>Let's begin with the landing page. Create a new file <code>src/templates/index.rs</code> and put the following inside:</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perseus::{GenericNode, StringResultWithCause, Template};
use serde::{Deserialize, Serialize};
use std::rc::Rc;
use sycamore::prelude::{component, template, Template as SycamoreTemplate};

#[derive(Serialize, Deserialize, Debug)]
pub struct IndexPageProps {
    pub greeting: String,
}

#[component(IndexPage&lt;G&gt;)]
pub fn index_page(props: IndexPageProps) -&gt; SycamoreTemplate&lt;G&gt; {
    template! {
        p {(props.greeting)}
        a(href = &quot;/about&quot;) { &quot;About!&quot; }
    }
}

pub fn get_template&lt;G: GenericNode&gt;() -&gt; Template&lt;G&gt; {
    Template::new(&quot;index&quot;)
        .build_state_fn(Rc::new(get_build_props))
        .template(template_fn())
        .head(head_fn())
}

pub async fn get_build_props(_path: String) -&gt; StringResultWithCause&lt;String&gt; {
    Ok(serde_json::to_string(&amp;IndexPageProps {
        greeting: &quot;Hello World!&quot;.to_string(),
    })
    .unwrap())
}

pub fn template_fn&lt;G: GenericNode&gt;() -&gt; perseus::template::TemplateFn&lt;G&gt; {
    Rc::new(|props: Option&lt;String&gt;| {
        template! {
            IndexPage(
                serde_json::from_str::&lt;IndexPageProps&gt;(&amp;props.unwrap()).unwrap()
            )
        }
    })
}

pub fn head_fn() -&gt; perseus::template::HeadFn {
    Rc::new(|_| {
        template! {
            title { &quot;Index Page | Perseus Example ‚Äì Basic&quot; }
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>This code is <em>much</em> more complex than the <em>Hello World!</em> example, so let's go through it carefully.</p>
<p>First, we import a whole ton of stuff:</p>
<ul>
<li><code>perseus</code>
<ul>
<li><code>StringResultWithCause</code> -- see below for an explanation of this</li>
<li><code>Template</code> -- as before</li>
<li><code>GenericNode</code> -- as before</li>
</ul>
</li>
<li><code>serde</code>
<ul>
<li><code>Serialize</code> -- a trait for <code>struct</code>s that can be turned into a string (like JSON)</li>
<li><code>Deserialize</code> -- a trait for <code>struct</code>s that can be <em>de</em>serialized from a string (like JSON)</li>
</ul>
</li>
<li><code>std::rc::Rc</code> -- same as before, you can read more about <code>Rc</code>s <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html">here</a></li>
<li><code>sycamore</code>
<ul>
<li><code>component</code> -- a macro that turns a function into a Sycamore component</li>
<li><code>template</code> -- the <code>template!</code> macro, same as before</li>
<li><code>Template as SycamoreTemplate</code> -- the output of the <code>template!</code> macro, aliased as <code>SycamoreTemplate</code> so it doesn't conflict with <code>perseus::Template</code>, which is very different</li>
</ul>
</li>
</ul>
<p>Then we define a number of different functions and a <code>struct</code>, each of which gets a section now.</p>
<h3 id="indexpageprops"><a class="header" href="#indexpageprops"><code>IndexPageProps</code></a></h3>
<p>This <code>struct</code> represents the properties that the index page will take. In this case, we're building an index page that will display a greeting defined in this, specifically in the <code>greeting</code> property.</p>
<p>Any template can take arguments in Perseus, which should always be given inside a <code>struct</code>. For simplicity and performance, Perseus only ever passes your properties around as a <code>String</code>, so you'll need to serialize/deserialize them yourself (as in the functions below).</p>
<h3 id="index_page"><a class="header" href="#index_page"><code>index_page()</code></a></h3>
<p>This is the actual component that your page is. Technically, you could just put this under <code>template_fn()</code>, but it's conventional to break it out independently. By annotating it with <code>#[component(IndexPage&lt;G&gt;)]</code>, we tell Sycamore to turn it into a complex <code>struct</code> that can be called inside <code>template!</code> (which we do in <code>template_fn()</code>).</p>
<p>Note that this takes <code>IndexPageProps</code> as an argument, which it can then access in the <code>template!</code>. This is Sycamore's interpolation system, which you can read about <a href="https://sycamore-rs.netlify.app/docs/basics/template">here</a>, but all you need to know is that it's basically seamless and works exactly as you'd expect.</p>
<p>The only other thing we do here is define an <code>&lt;a&gt;</code> (an HTML link) to <code>/about</code>. This link, and any others you define, will automatically be detected by Sycamore's systems, which will pass them to Perseus' routing logic, which means your users <strong>never leave the page</strong>. In this way, Perseus only pulls in the content that needs to change, and gives your users the feeling of a lightning-fast and weightless app.</p>
<p><em>Note: external links will automatically be excluded from this, and you can exclude manually by adding <code>rel=&quot;external&quot;</code> if you need.</em></p>
<h3 id="get_template"><a class="header" href="#get_template"><code>get_template()</code></a></h3>
<p>This function is what we call in <code>lib.rs</code>, and it combines everything else in this file to produce an actual Perseus <code>Template</code> to be used. Note the name of the template as <code>index</code>, which Perseus interprets as special, which causes this template to be rendered at <code>/</code> (the landing page).</p>
<p>Perseus' templating system is extremely versatile, and here we're using it to define our page itself through <code>.template()</code>, and to define a function that will modify the document <code>&lt;head&gt;</code> (which allows us to add a title) with <code>.head()</code>. Notably, we also use the <em>build state</em> rendering strategy, which tells Perseus to call the <code>get_build_props()</code> function when your app builds to get some state. More on that now.</p>
<h3 id="get_build_props"><a class="header" href="#get_build_props"><code>get_build_props()</code></a></h3>
<p>This function is part of Perseus' secret sauce (actually <em>open</em> sauce), and it will be called when the CLI builds your app to create properties that the template will take (it expects a string, hence the serialization). Here, we just hard-code a greeting in to be used, but the real power of this comes when you start using the fact that this function is <code>async</code>. You might query a database to get a list of blog posts, or pull in a Markdown documentation page and parse it, the possibilities are endless!</p>
<p>Note that this function returns a <code>StringResultWithCause&lt;String&gt;</code>, which means that it returns a normal Rust <code>Result&lt;String, E&gt;</code>, where <code>E</code> is a tuple of a <code>String</code> error message and a declaration of who caused the error (either the client or the server). This becomes important when you combine this rendering strategy with others, which are explained in depth later in the book.</p>
<h3 id="template_fn"><a class="header" href="#template_fn"><code>template_fn()</code></a></h3>
<p>The result of this function is what Perseus will call when it wants to render your template (which it does more than you might think), and it passes it the props that your template takes as an <code>Option&lt;String&gt;</code>. This might seem a bit weird, but there are reasons under the hood. All you need to know here is that if your template takes any properties, they <strong>will</strong> be here, and it's safe to <code>.unwrap()</code> them for deserialization.</p>
<h3 id="head_fn"><a class="header" href="#head_fn"><code>head_fn()</code></a></h3>
<p>This is very similar to <code>template_fn</code>, except it can't be reactive. In other words, anything you put in here is like a picture, it can't move (so no buttons, counters, etc.). This is because this modifies the document <code>&lt;head&gt;</code>, so you should put metadata, titles, etc. in here. Note that the function we return from here does take an argument (ignored with <code>_</code>), that's a string of the properties to your app, but we don't need it in this example. If this page was a generic template for blog posts, you might use this capability to render a different title for each blog post.</p>
<p>All this does though is set the <code>&lt;title&gt;</code>. If you inspect the source code of the HTML in your browser, you'll find a big comment in the <code>&lt;head&gt;</code> that says <code>&lt;!--PERSEUS_INTERPOLATED_HEAD_BEGINS--&gt;</code>, that separates the stuff that should remain the same on every page from the stuff that should update for each page.</p>
<h2 id="aboutrs"><a class="header" href="#aboutrs"><code>about.rs</code></a></h2>
<p>Okay! We're past the hump, and now it's time to define the (much simpler) <code>/about</code> page. Create <code>src/templates/about.rs</code> and put the following inside:</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perseus::Template;
use std::rc::Rc;
use sycamore::prelude::{component, template, GenericNode, Template as SycamoreTemplate};

#[component(AboutPage&lt;G&gt;)]
pub fn about_page() -&gt; SycamoreTemplate&lt;G&gt; {
    template! {
        p { &quot;About.&quot; }
    }
}

pub fn get_template&lt;G: GenericNode&gt;() -&gt; Template&lt;G&gt; {
    Template::new(&quot;about&quot;)
        .template(template_fn())
        .head(head_fn())
}

pub fn template_fn&lt;G: GenericNode&gt;() -&gt; perseus::template::TemplateFn&lt;G&gt; {
    Rc::new(|_| {
        template! {
            AboutPage()
        }
    })
}

pub fn head_fn() -&gt; perseus::template::HeadFn {
    Rc::new(|_| {
        template! {
            title { &quot;About Page | Perseus Example ‚Äì Basic&quot; }
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>This is basically exactly the same as <code>index.rs</code>, except we don't have any properties to deal with, and we don't need to generate anything special at build time (but Perseus will still render this page to static HTML, ready to be served to your users).</p>
<h2 id="running-it"><a class="header" href="#running-it">Running It</a></h2>
<p><code>perseus serve</code></p>
<p>That's all. Every time you build a Perseus app, that's all you need to do.</p>
<p>Once this is finished, your app will be live at <a href="http://localhost:8080">http://localhost:8080</a>! Note that if you don't like that, you can change the host/port with the <code>HOST</code>/<code>PORT</code> environment variables (e.g. you'd want to set the host to <code>0.0.0.0</code> if you want other people on your network to be able to access your site).</p>
<p>Hop over to <a href="http://localhost:8080">http://localhost:8080</a> in any modern browser and you should see your greeting <code>Hello World!</code> above a link to the about page! if you click that link, you'll be taken to a page that just says <code>About.</code>, but notice how your browser seemingly never navigates to a new page (the tab doesn't show a loading icon)? That's Perseus' <em>app shell</em> in action, which intercepts navigation to other pages and makes it occur seamlessly, only fetching the bare minimum to make the new page load. The same behavior will occur if you use your browser's forward/backward buttons.</p>
<details>
<summary>Why a 'modern browser'?</summary>
<h3 id="browser-compatibility"><a class="header" href="#browser-compatibility">Browser Compatibility</a></h3>
<p>Perseus is compatible with any browser that supports Wasm, which is most modern browsers like Firefox and Chrome. However, legacy browsers like Internet Explorer will not work with any Perseus app, unless you <em>polyfill</em> support for WebAssembly.</p>
</details>
<p>By the way, remember this little bit of code in <code>src/lib.rs</code>?</p>
<pre><pre class="playground"><code class="language-rust no_run no_playground edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    static_aliases: {
        &quot;/test.txt&quot; =&gt; &quot;static/test.txt&quot;
    }
<span class="boring">}
</span></code></pre></pre>
<p>If you navigate to <a href="http://localhost:8080/test.txt">http://localhost:8080/test.txt</a>, you should see the contents on <code>static/test.txt</code>! You can also access them at <a href="http://localhost:8080/.perseus/static/test.txt">http://localhost:8080/.perseus/static/test.txt</a></p>
<h2 id="moving-forward-1"><a class="header" href="#moving-forward-1">Moving Forward</a></h2>
<p>Congratulations! You're now well on your way to building highly performant web apps in Rust! The remaining sections of this book are more reference-style, and won't guide you through building an app, but they'll focus instead on specific features of Perseus that can be used to make extremely powerful systems.</p>
<p>So go forth, and build!</p>

                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->
                    
                    
                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
            
                    </nav>

    </div>

    
    
    
        <script type="text/javascript">
        window.playground_copyable = true;
    </script>
    
    
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
    
    <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
    <script src="book.js" type="text/javascript" charset="utf-8"></script>

    <!-- Custom JS scripts -->
    
            <script type="text/javascript">
        window.addEventListener('load', function () {
            window.setTimeout(window.print, 100);
        });
    </script>
        
</body>

</html>
